//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g 2011-12-13 07:33:20

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
public partial class EnumReflectorParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BITFIELD", "COMMA", "DIGIT", "ENUM", "ENUM_BEGIN", "ENUM_END", "ENUM_ENTRY", "EQUALS", "HEX_DIGIT", "ID", "LBRACE", "LEFT_SHIFT", "LPAREN", "META", "POSITIVE_INTEGER10", "POSITIVE_INTEGER16", "POS_DIGIT", "RBRACE", "RPAREN", "SEMICOLON", "STRING", "WHITESPACE"
	};
	public const int EOF=-1;
	public const int BITFIELD=4;
	public const int COMMA=5;
	public const int DIGIT=6;
	public const int ENUM=7;
	public const int ENUM_BEGIN=8;
	public const int ENUM_END=9;
	public const int ENUM_ENTRY=10;
	public const int EQUALS=11;
	public const int HEX_DIGIT=12;
	public const int ID=13;
	public const int LBRACE=14;
	public const int LEFT_SHIFT=15;
	public const int LPAREN=16;
	public const int META=17;
	public const int POSITIVE_INTEGER10=18;
	public const int POSITIVE_INTEGER16=19;
	public const int POS_DIGIT=20;
	public const int RBRACE=21;
	public const int RPAREN=22;
	public const int SEMICOLON=23;
	public const int STRING=24;
	public const int WHITESPACE=25;

	public EnumReflectorParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public EnumReflectorParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return EnumReflectorParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_enum_conversion_tag();
	partial void LeaveRule_enum_conversion_tag();

	// $ANTLR start "enum_conversion_tag"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:29:1: enum_conversion_tag : META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !;
	[GrammarRule("enum_conversion_tag")]
	private AstParserRuleReturnScope<object, IToken> enum_conversion_tag()
	{
		EnterRule_enum_conversion_tag();
		EnterRule("enum_conversion_tag", 1);
		TraceIn("enum_conversion_tag", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META1 = default(IToken);
		IToken ENUM_ENTRY2 = default(IToken);
		IToken LPAREN3 = default(IToken);
		IToken STRING4 = default(IToken);
		IToken RPAREN5 = default(IToken);

		object META1_tree = default(object);
		object ENUM_ENTRY2_tree = default(object);
		object LPAREN3_tree = default(object);
		object STRING4_tree = default(object);
		object RPAREN5_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_conversion_tag");
		DebugLocation(29, 44);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:30:2: ( META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:30:4: META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(30, 8);
			META1=(IToken)Match(input,META,Follow._META_in_enum_conversion_tag169); 
			DebugLocation(30, 20);
			ENUM_ENTRY2=(IToken)Match(input,ENUM_ENTRY,Follow._ENUM_ENTRY_in_enum_conversion_tag172); 
			ENUM_ENTRY2_tree = (object)adaptor.Create(ENUM_ENTRY2);
			root_0 = (object)adaptor.BecomeRoot(ENUM_ENTRY2_tree, root_0);
			DebugLocation(30, 28);
			LPAREN3=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_conversion_tag175); 
			DebugLocation(30, 30);
			STRING4=(IToken)Match(input,STRING,Follow._STRING_in_enum_conversion_tag178); 
			STRING4_tree = (object)adaptor.Create(STRING4);
			adaptor.AddChild(root_0, STRING4_tree);
			DebugLocation(30, 43);
			RPAREN5=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_conversion_tag180); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_conversion_tag", 1);
			LeaveRule("enum_conversion_tag", 1);
			LeaveRule_enum_conversion_tag();
		}
		DebugLocation(30, 44);
		} finally { DebugExitRule(GrammarFileName, "enum_conversion_tag"); }
		return retval;

	}
	// $ANTLR end "enum_conversion_tag"

	partial void EnterRule_shift_expression();
	partial void LeaveRule_shift_expression();

	// $ANTLR start "shift_expression"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:32:1: shift_expression : POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 ;
	[GrammarRule("shift_expression")]
	private AstParserRuleReturnScope<object, IToken> shift_expression()
	{
		EnterRule_shift_expression();
		EnterRule("shift_expression", 2);
		TraceIn("shift_expression", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken POSITIVE_INTEGER106 = default(IToken);
		IToken LEFT_SHIFT7 = default(IToken);
		IToken POSITIVE_INTEGER108 = default(IToken);

		object POSITIVE_INTEGER106_tree = default(object);
		object LEFT_SHIFT7_tree = default(object);
		object POSITIVE_INTEGER108_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "shift_expression");
		DebugLocation(32, 53);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:2: ( POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:4: POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(33, 4);
			POSITIVE_INTEGER106=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression191); 
			POSITIVE_INTEGER106_tree = (object)adaptor.Create(POSITIVE_INTEGER106);
			adaptor.AddChild(root_0, POSITIVE_INTEGER106_tree);
			DebugLocation(33, 33);
			LEFT_SHIFT7=(IToken)Match(input,LEFT_SHIFT,Follow._LEFT_SHIFT_in_shift_expression193); 
			LEFT_SHIFT7_tree = (object)adaptor.Create(LEFT_SHIFT7);
			root_0 = (object)adaptor.BecomeRoot(LEFT_SHIFT7_tree, root_0);
			DebugLocation(33, 35);
			POSITIVE_INTEGER108=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression196); 
			POSITIVE_INTEGER108_tree = (object)adaptor.Create(POSITIVE_INTEGER108);
			adaptor.AddChild(root_0, POSITIVE_INTEGER108_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_expression", 2);
			LeaveRule("shift_expression", 2);
			LeaveRule_shift_expression();
		}
		DebugLocation(33, 53);
		} finally { DebugExitRule(GrammarFileName, "shift_expression"); }
		return retval;

	}
	// $ANTLR end "shift_expression"

	partial void EnterRule_integer_constant();
	partial void LeaveRule_integer_constant();

	// $ANTLR start "integer_constant"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:35:1: integer_constant : ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 );
	[GrammarRule("integer_constant")]
	private AstParserRuleReturnScope<object, IToken> integer_constant()
	{
		EnterRule_integer_constant();
		EnterRule("integer_constant", 3);
		TraceIn("integer_constant", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken POSITIVE_INTEGER1610 = default(IToken);
		IToken POSITIVE_INTEGER1011 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shift_expression9 = default(AstParserRuleReturnScope<object, IToken>);

		object POSITIVE_INTEGER1610_tree = default(object);
		object POSITIVE_INTEGER1011_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "integer_constant");
		DebugLocation(35, 62);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:2: ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 )
			int alt1=3;
			try { DebugEnterDecision(1, false);
			int LA1_0 = input.LA(1);

			if ((LA1_0==POSITIVE_INTEGER10))
			{
				int LA1_1 = input.LA(2);

				if ((LA1_1==LEFT_SHIFT))
				{
					alt1 = 1;
				}
				else if ((LA1_1==COMMA||LA1_1==META||LA1_1==RBRACE))
				{
					alt1 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_0==POSITIVE_INTEGER16))
			{
				alt1 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:4: shift_expression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(36, 4);
				PushFollow(Follow._shift_expression_in_integer_constant209);
				shift_expression9=shift_expression();
				PopFollow();

				adaptor.AddChild(root_0, shift_expression9.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:23: POSITIVE_INTEGER16
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(36, 23);
				POSITIVE_INTEGER1610=(IToken)Match(input,POSITIVE_INTEGER16,Follow._POSITIVE_INTEGER16_in_integer_constant213); 
				POSITIVE_INTEGER1610_tree = (object)adaptor.Create(POSITIVE_INTEGER1610);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1610_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:44: POSITIVE_INTEGER10
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(36, 44);
				POSITIVE_INTEGER1011=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_integer_constant217); 
				POSITIVE_INTEGER1011_tree = (object)adaptor.Create(POSITIVE_INTEGER1011);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1011_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("integer_constant", 3);
			LeaveRule("integer_constant", 3);
			LeaveRule_integer_constant();
		}
		DebugLocation(36, 62);
		} finally { DebugExitRule(GrammarFileName, "integer_constant"); }
		return retval;

	}
	// $ANTLR end "integer_constant"

	partial void EnterRule_value_assignment();
	partial void LeaveRule_value_assignment();

	// $ANTLR start "value_assignment"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:1: value_assignment : EQUALS ! integer_constant ;
	[GrammarRule("value_assignment")]
	private AstParserRuleReturnScope<object, IToken> value_assignment()
	{
		EnterRule_value_assignment();
		EnterRule("value_assignment", 4);
		TraceIn("value_assignment", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUALS12 = default(IToken);
		AstParserRuleReturnScope<object, IToken> integer_constant13 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUALS12_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_assignment");
		DebugLocation(38, 28);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:39:2: ( EQUALS ! integer_constant )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:39:4: EQUALS ! integer_constant
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(39, 10);
			EQUALS12=(IToken)Match(input,EQUALS,Follow._EQUALS_in_value_assignment227); 
			DebugLocation(39, 12);
			PushFollow(Follow._integer_constant_in_value_assignment230);
			integer_constant13=integer_constant();
			PopFollow();

			adaptor.AddChild(root_0, integer_constant13.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_assignment", 4);
			LeaveRule("value_assignment", 4);
			LeaveRule_value_assignment();
		}
		DebugLocation(39, 28);
		} finally { DebugExitRule(GrammarFileName, "value_assignment"); }
		return retval;

	}
	// $ANTLR end "value_assignment"

	partial void EnterRule_last_enum_entry();
	partial void LeaveRule_last_enum_entry();

	// $ANTLR start "last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:41:1: last_enum_entry : ID ^ ( value_assignment )? ( enum_conversion_tag )? ;
	[GrammarRule("last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> last_enum_entry()
	{
		EnterRule_last_enum_entry();
		EnterRule("last_enum_entry", 5);
		TraceIn("last_enum_entry", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID14 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_assignment15 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_conversion_tag16 = default(AstParserRuleReturnScope<object, IToken>);

		object ID14_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "last_enum_entry");
		DebugLocation(41, 46);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:2: ( ID ^ ( value_assignment )? ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:4: ID ^ ( value_assignment )? ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(42, 6);
			ID14=(IToken)Match(input,ID,Follow._ID_in_last_enum_entry240); 
			ID14_tree = (object)adaptor.Create(ID14);
			root_0 = (object)adaptor.BecomeRoot(ID14_tree, root_0);
			DebugLocation(42, 8);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:8: ( value_assignment )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==EQUALS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:8: value_assignment
				{
				DebugLocation(42, 8);
				PushFollow(Follow._value_assignment_in_last_enum_entry243);
				value_assignment15=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment15.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(42, 26);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:26: ( enum_conversion_tag )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==META))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:26: enum_conversion_tag
				{
				DebugLocation(42, 26);
				PushFollow(Follow._enum_conversion_tag_in_last_enum_entry246);
				enum_conversion_tag16=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("last_enum_entry", 5);
			LeaveRule("last_enum_entry", 5);
			LeaveRule_last_enum_entry();
		}
		DebugLocation(42, 46);
		} finally { DebugExitRule(GrammarFileName, "last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "last_enum_entry"

	partial void EnterRule_non_last_enum_entry();
	partial void LeaveRule_non_last_enum_entry();

	// $ANTLR start "non_last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:1: non_last_enum_entry : ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )? ;
	[GrammarRule("non_last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> non_last_enum_entry()
	{
		EnterRule_non_last_enum_entry();
		EnterRule("non_last_enum_entry", 6);
		TraceIn("non_last_enum_entry", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID17 = default(IToken);
		IToken COMMA19 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_assignment18 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_conversion_tag20 = default(AstParserRuleReturnScope<object, IToken>);

		object ID17_tree = default(object);
		object COMMA19_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "non_last_enum_entry");
		DebugLocation(44, 53);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:2: ( ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:4: ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(45, 6);
			ID17=(IToken)Match(input,ID,Follow._ID_in_non_last_enum_entry257); 
			ID17_tree = (object)adaptor.Create(ID17);
			root_0 = (object)adaptor.BecomeRoot(ID17_tree, root_0);
			DebugLocation(45, 8);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:8: ( value_assignment )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==EQUALS))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:8: value_assignment
				{
				DebugLocation(45, 8);
				PushFollow(Follow._value_assignment_in_non_last_enum_entry260);
				value_assignment18=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment18.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(45, 31);
			COMMA19=(IToken)Match(input,COMMA,Follow._COMMA_in_non_last_enum_entry263); 
			DebugLocation(45, 33);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:33: ( enum_conversion_tag )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==META))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:33: enum_conversion_tag
				{
				DebugLocation(45, 33);
				PushFollow(Follow._enum_conversion_tag_in_non_last_enum_entry266);
				enum_conversion_tag20=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag20.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("non_last_enum_entry", 6);
			LeaveRule("non_last_enum_entry", 6);
			LeaveRule_non_last_enum_entry();
		}
		DebugLocation(45, 53);
		} finally { DebugExitRule(GrammarFileName, "non_last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "non_last_enum_entry"

	partial void EnterRule_enum_entry_list();
	partial void LeaveRule_enum_entry_list();

	// $ANTLR start "enum_entry_list"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:1: enum_entry_list : LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !;
	[GrammarRule("enum_entry_list")]
	private AstParserRuleReturnScope<object, IToken> enum_entry_list()
	{
		EnterRule_enum_entry_list();
		EnterRule("enum_entry_list", 7);
		TraceIn("enum_entry_list", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACE21 = default(IToken);
		IToken RBRACE24 = default(IToken);
		AstParserRuleReturnScope<object, IToken> non_last_enum_entry22 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> last_enum_entry23 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACE21_tree = default(object);
		object RBRACE24_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_entry_list");
		DebugLocation(47, 57);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:2: ( LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:4: LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(48, 10);
			LBRACE21=(IToken)Match(input,LBRACE,Follow._LBRACE_in_enum_entry_list278); 
			LBRACE21_tree = (object)adaptor.Create(LBRACE21);
			root_0 = (object)adaptor.BecomeRoot(LBRACE21_tree, root_0);
			DebugLocation(48, 12);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:12: ( non_last_enum_entry )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==ID))
				{
					int LA6_1 = input.LA(2);

					if ((LA6_1==EQUALS))
					{
						int LA6_2 = input.LA(3);

						if ((LA6_2==POSITIVE_INTEGER10))
						{
							int LA6_5 = input.LA(4);

							if ((LA6_5==LEFT_SHIFT))
							{
								int LA6_7 = input.LA(5);

								if ((LA6_7==POSITIVE_INTEGER10))
								{
									int LA6_8 = input.LA(6);

									if ((LA6_8==COMMA))
									{
										alt6 = 1;
									}


								}


							}
							else if ((LA6_5==COMMA))
							{
								alt6 = 1;
							}


						}
						else if ((LA6_2==POSITIVE_INTEGER16))
						{
							int LA6_6 = input.LA(4);

							if ((LA6_6==COMMA))
							{
								alt6 = 1;
							}


						}


					}
					else if ((LA6_1==COMMA))
					{
						alt6 = 1;
					}


				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:12: non_last_enum_entry
					{
					DebugLocation(48, 12);
					PushFollow(Follow._non_last_enum_entry_in_enum_entry_list281);
					non_last_enum_entry22=non_last_enum_entry();
					PopFollow();

					adaptor.AddChild(root_0, non_last_enum_entry22.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(48, 33);
			PushFollow(Follow._last_enum_entry_in_enum_entry_list284);
			last_enum_entry23=last_enum_entry();
			PopFollow();

			adaptor.AddChild(root_0, last_enum_entry23.Tree);
			DebugLocation(48, 56);
			RBRACE24=(IToken)Match(input,RBRACE,Follow._RBRACE_in_enum_entry_list287); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_entry_list", 7);
			LeaveRule("enum_entry_list", 7);
			LeaveRule_enum_entry_list();
		}
		DebugLocation(48, 57);
		} finally { DebugExitRule(GrammarFileName, "enum_entry_list"); }
		return retval;

	}
	// $ANTLR end "enum_entry_list"

	partial void EnterRule_enum_definition();
	partial void LeaveRule_enum_definition();

	// $ANTLR start "enum_definition"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:50:1: enum_definition : ENUM ^ ID enum_entry_list SEMICOLON !;
	[GrammarRule("enum_definition")]
	private AstParserRuleReturnScope<object, IToken> enum_definition()
	{
		EnterRule_enum_definition();
		EnterRule("enum_definition", 8);
		TraceIn("enum_definition", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ENUM25 = default(IToken);
		IToken ID26 = default(IToken);
		IToken SEMICOLON28 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enum_entry_list27 = default(AstParserRuleReturnScope<object, IToken>);

		object ENUM25_tree = default(object);
		object ID26_tree = default(object);
		object SEMICOLON28_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_definition");
		DebugLocation(50, 39);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:2: ( ENUM ^ ID enum_entry_list SEMICOLON !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:4: ENUM ^ ID enum_entry_list SEMICOLON !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(51, 8);
			ENUM25=(IToken)Match(input,ENUM,Follow._ENUM_in_enum_definition298); 
			ENUM25_tree = (object)adaptor.Create(ENUM25);
			root_0 = (object)adaptor.BecomeRoot(ENUM25_tree, root_0);
			DebugLocation(51, 10);
			ID26=(IToken)Match(input,ID,Follow._ID_in_enum_definition301); 
			ID26_tree = (object)adaptor.Create(ID26);
			adaptor.AddChild(root_0, ID26_tree);
			DebugLocation(51, 13);
			PushFollow(Follow._enum_entry_list_in_enum_definition303);
			enum_entry_list27=enum_entry_list();
			PopFollow();

			adaptor.AddChild(root_0, enum_entry_list27.Tree);
			DebugLocation(51, 38);
			SEMICOLON28=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_enum_definition305); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_definition", 8);
			LeaveRule("enum_definition", 8);
			LeaveRule_enum_definition();
		}
		DebugLocation(51, 39);
		} finally { DebugExitRule(GrammarFileName, "enum_definition"); }
		return retval;

	}
	// $ANTLR end "enum_definition"

	partial void EnterRule_enum_properties();
	partial void LeaveRule_enum_properties();

	// $ANTLR start "enum_properties"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:53:1: enum_properties : BITFIELD ;
	[GrammarRule("enum_properties")]
	private AstParserRuleReturnScope<object, IToken> enum_properties()
	{
		EnterRule_enum_properties();
		EnterRule("enum_properties", 9);
		TraceIn("enum_properties", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BITFIELD29 = default(IToken);

		object BITFIELD29_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_properties");
		DebugLocation(53, 12);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:2: ( BITFIELD )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:4: BITFIELD
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(54, 4);
			BITFIELD29=(IToken)Match(input,BITFIELD,Follow._BITFIELD_in_enum_properties316); 
			BITFIELD29_tree = (object)adaptor.Create(BITFIELD29);
			adaptor.AddChild(root_0, BITFIELD29_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_properties", 9);
			LeaveRule("enum_properties", 9);
			LeaveRule_enum_properties();
		}
		DebugLocation(54, 12);
		} finally { DebugExitRule(GrammarFileName, "enum_properties"); }
		return retval;

	}
	// $ANTLR end "enum_properties"

	partial void EnterRule_enum_begin_meta();
	partial void LeaveRule_enum_begin_meta();

	// $ANTLR start "enum_begin_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:56:1: enum_begin_meta : META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !;
	[GrammarRule("enum_begin_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_begin_meta()
	{
		EnterRule_enum_begin_meta();
		EnterRule("enum_begin_meta", 10);
		TraceIn("enum_begin_meta", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META30 = default(IToken);
		IToken ENUM_BEGIN31 = default(IToken);
		IToken LPAREN32 = default(IToken);
		IToken RPAREN34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enum_properties33 = default(AstParserRuleReturnScope<object, IToken>);

		object META30_tree = default(object);
		object ENUM_BEGIN31_tree = default(object);
		object LPAREN32_tree = default(object);
		object RPAREN34_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_begin_meta");
		DebugLocation(56, 54);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:2: ( META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:4: META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(57, 8);
			META30=(IToken)Match(input,META,Follow._META_in_enum_begin_meta327); 
			DebugLocation(57, 20);
			ENUM_BEGIN31=(IToken)Match(input,ENUM_BEGIN,Follow._ENUM_BEGIN_in_enum_begin_meta330); 
			ENUM_BEGIN31_tree = (object)adaptor.Create(ENUM_BEGIN31);
			root_0 = (object)adaptor.BecomeRoot(ENUM_BEGIN31_tree, root_0);
			DebugLocation(57, 28);
			LPAREN32=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_begin_meta333); 
			DebugLocation(57, 30);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:30: ( enum_properties )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==BITFIELD))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:30: enum_properties
				{
				DebugLocation(57, 30);
				PushFollow(Follow._enum_properties_in_enum_begin_meta336);
				enum_properties33=enum_properties();
				PopFollow();

				adaptor.AddChild(root_0, enum_properties33.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(57, 53);
			RPAREN34=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_begin_meta339); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_begin_meta", 10);
			LeaveRule("enum_begin_meta", 10);
			LeaveRule_enum_begin_meta();
		}
		DebugLocation(57, 54);
		} finally { DebugExitRule(GrammarFileName, "enum_begin_meta"); }
		return retval;

	}
	// $ANTLR end "enum_begin_meta"

	partial void EnterRule_enum_end_meta();
	partial void LeaveRule_enum_end_meta();

	// $ANTLR start "enum_end_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:59:1: enum_end_meta : META ! ENUM_END ^;
	[GrammarRule("enum_end_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_end_meta()
	{
		EnterRule_enum_end_meta();
		EnterRule("enum_end_meta", 11);
		TraceIn("enum_end_meta", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META35 = default(IToken);
		IToken ENUM_END36 = default(IToken);

		object META35_tree = default(object);
		object ENUM_END36_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_end_meta");
		DebugLocation(59, 19);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:60:2: ( META ! ENUM_END ^)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:60:4: META ! ENUM_END ^
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(60, 8);
			META35=(IToken)Match(input,META,Follow._META_in_enum_end_meta351); 
			DebugLocation(60, 18);
			ENUM_END36=(IToken)Match(input,ENUM_END,Follow._ENUM_END_in_enum_end_meta354); 
			ENUM_END36_tree = (object)adaptor.Create(ENUM_END36);
			root_0 = (object)adaptor.BecomeRoot(ENUM_END36_tree, root_0);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_end_meta", 11);
			LeaveRule("enum_end_meta", 11);
			LeaveRule_enum_end_meta();
		}
		DebugLocation(60, 19);
		} finally { DebugExitRule(GrammarFileName, "enum_end_meta"); }
		return retval;

	}
	// $ANTLR end "enum_end_meta"

	partial void EnterRule_parse();
	partial void LeaveRule_parse();

	// $ANTLR start "parse"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:62:8: public parse : enum_begin_meta enum_definition enum_end_meta ;
	[GrammarRule("parse")]
	public AstParserRuleReturnScope<object, IToken> parse()
	{
		EnterRule_parse();
		EnterRule("parse", 12);
		TraceIn("parse", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> enum_begin_meta37 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_definition38 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_end_meta39 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "parse");
		DebugLocation(62, 49);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:63:2: ( enum_begin_meta enum_definition enum_end_meta )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:63:4: enum_begin_meta enum_definition enum_end_meta
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(63, 4);
			PushFollow(Follow._enum_begin_meta_in_parse367);
			enum_begin_meta37=enum_begin_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_begin_meta37.Tree);
			DebugLocation(63, 20);
			PushFollow(Follow._enum_definition_in_parse369);
			enum_definition38=enum_definition();
			PopFollow();

			adaptor.AddChild(root_0, enum_definition38.Tree);
			DebugLocation(63, 36);
			PushFollow(Follow._enum_end_meta_in_parse371);
			enum_end_meta39=enum_end_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_end_meta39.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parse", 12);
			LeaveRule("parse", 12);
			LeaveRule_parse();
		}
		DebugLocation(63, 49);
		} finally { DebugExitRule(GrammarFileName, "parse"); }
		return retval;

	}
	// $ANTLR end "parse"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _META_in_enum_conversion_tag169 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ENUM_ENTRY_in_enum_conversion_tag172 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _LPAREN_in_enum_conversion_tag175 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _STRING_in_enum_conversion_tag178 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _RPAREN_in_enum_conversion_tag180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression191 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _LEFT_SHIFT_in_shift_expression193 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression196 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_expression_in_integer_constant209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER16_in_integer_constant213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_integer_constant217 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQUALS_in_value_assignment227 = new BitSet(new ulong[]{0xC0000UL});
		public static readonly BitSet _integer_constant_in_value_assignment230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_last_enum_entry240 = new BitSet(new ulong[]{0x20802UL});
		public static readonly BitSet _value_assignment_in_last_enum_entry243 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _enum_conversion_tag_in_last_enum_entry246 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_non_last_enum_entry257 = new BitSet(new ulong[]{0x820UL});
		public static readonly BitSet _value_assignment_in_non_last_enum_entry260 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_non_last_enum_entry263 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _enum_conversion_tag_in_non_last_enum_entry266 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_enum_entry_list278 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _non_last_enum_entry_in_enum_entry_list281 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _last_enum_entry_in_enum_entry_list284 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _RBRACE_in_enum_entry_list287 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ENUM_in_enum_definition298 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _ID_in_enum_definition301 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _enum_entry_list_in_enum_definition303 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _SEMICOLON_in_enum_definition305 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BITFIELD_in_enum_properties316 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_begin_meta327 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ENUM_BEGIN_in_enum_begin_meta330 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _LPAREN_in_enum_begin_meta333 = new BitSet(new ulong[]{0x400010UL});
		public static readonly BitSet _enum_properties_in_enum_begin_meta336 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _RPAREN_in_enum_begin_meta339 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_end_meta351 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ENUM_END_in_enum_end_meta354 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enum_begin_meta_in_parse367 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _enum_definition_in_parse369 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _enum_end_meta_in_parse371 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
