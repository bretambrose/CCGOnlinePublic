//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g 2011-12-10 17:13:14

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 168, 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;
using ConditionalAttribute = System.Diagnostics.ConditionalAttribute;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
public partial class EnumReflectorParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BITFIELD", "COMMA", "DIGIT", "ENUM", "ENUM_BEGIN", "ENUM_END", "ENUM_ENTRY", "EQUALS", "HEX_DIGIT", "ID", "LBRACE", "LEFT_SHIFT", "LPAREN", "META", "POSITIVE_INTEGER10", "POSITIVE_INTEGER16", "POS_DIGIT", "RBRACE", "RPAREN", "SEMICOLON", "STRING", "WHITESPACE"
	};
	public const int EOF=-1;
	public const int BITFIELD=4;
	public const int COMMA=5;
	public const int DIGIT=6;
	public const int ENUM=7;
	public const int ENUM_BEGIN=8;
	public const int ENUM_END=9;
	public const int ENUM_ENTRY=10;
	public const int EQUALS=11;
	public const int HEX_DIGIT=12;
	public const int ID=13;
	public const int LBRACE=14;
	public const int LEFT_SHIFT=15;
	public const int LPAREN=16;
	public const int META=17;
	public const int POSITIVE_INTEGER10=18;
	public const int POSITIVE_INTEGER16=19;
	public const int POS_DIGIT=20;
	public const int RBRACE=21;
	public const int RPAREN=22;
	public const int SEMICOLON=23;
	public const int STRING=24;
	public const int WHITESPACE=25;

	#if ANTLR_DEBUG
		private static readonly bool[] decisionCanBacktrack =
			new bool[]
			{
				false, // invalid decision
				false, false, false, false, false, false, false
			};
	#else
		private static readonly bool[] decisionCanBacktrack = new bool[0];
	#endif
	public EnumReflectorParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public EnumReflectorParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		OnCreated();
	}
	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return EnumReflectorParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g"; } }


	[Conditional("ANTLR_TRACE")]
	protected virtual void OnCreated() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule(string ruleName, int ruleIndex) {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule(string ruleName, int ruleIndex) {}

	#region Rules

	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_enum_conversion_tag() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_enum_conversion_tag() {}

	// $ANTLR start "enum_conversion_tag"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:29:1: enum_conversion_tag : META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !;
	[GrammarRule("enum_conversion_tag")]
	private AstParserRuleReturnScope<object, IToken> enum_conversion_tag()
	{
		EnterRule_enum_conversion_tag();
		EnterRule("enum_conversion_tag", 1);
		TraceIn("enum_conversion_tag", 1);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken META1 = default(IToken);
	    IToken ENUM_ENTRY2 = default(IToken);
	    IToken LPAREN3 = default(IToken);
	    IToken STRING4 = default(IToken);
	    IToken RPAREN5 = default(IToken);

	    object META1_tree = default(object);
	    object ENUM_ENTRY2_tree = default(object);
	    object LPAREN3_tree = default(object);
	    object STRING4_tree = default(object);
	    object RPAREN5_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "enum_conversion_tag");
		DebugLocation(29, 44);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:30:2: ( META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:30:4: META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(30, 8);
			META1=(IToken)Match(input,META,Follow._META_in_enum_conversion_tag169); 
			DebugLocation(30, 20);
			ENUM_ENTRY2=(IToken)Match(input,ENUM_ENTRY,Follow._ENUM_ENTRY_in_enum_conversion_tag172); 
			ENUM_ENTRY2_tree = (object)adaptor.Create(ENUM_ENTRY2);
			root_0 = (object)adaptor.BecomeRoot(ENUM_ENTRY2_tree, root_0);

			DebugLocation(30, 28);
			LPAREN3=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_conversion_tag175); 
			DebugLocation(30, 30);
			STRING4=(IToken)Match(input,STRING,Follow._STRING_in_enum_conversion_tag178); 
			STRING4_tree = (object)adaptor.Create(STRING4);
			adaptor.AddChild(root_0, STRING4_tree);

			DebugLocation(30, 43);
			RPAREN5=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_conversion_tag180); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_conversion_tag", 1);
			LeaveRule("enum_conversion_tag", 1);
			LeaveRule_enum_conversion_tag();
	    }
	 	DebugLocation(30, 44);
		} finally { DebugExitRule(GrammarFileName, "enum_conversion_tag"); }
		return retval;

	}
	// $ANTLR end "enum_conversion_tag"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_shift_expression() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_shift_expression() {}

	// $ANTLR start "shift_expression"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:32:1: shift_expression : POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 ;
	[GrammarRule("shift_expression")]
	private AstParserRuleReturnScope<object, IToken> shift_expression()
	{
		EnterRule_shift_expression();
		EnterRule("shift_expression", 2);
		TraceIn("shift_expression", 2);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken POSITIVE_INTEGER106 = default(IToken);
	    IToken LEFT_SHIFT7 = default(IToken);
	    IToken POSITIVE_INTEGER108 = default(IToken);

	    object POSITIVE_INTEGER106_tree = default(object);
	    object LEFT_SHIFT7_tree = default(object);
	    object POSITIVE_INTEGER108_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "shift_expression");
		DebugLocation(32, 53);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:2: ( POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:4: POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(33, 4);
			POSITIVE_INTEGER106=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression191); 
			POSITIVE_INTEGER106_tree = (object)adaptor.Create(POSITIVE_INTEGER106);
			adaptor.AddChild(root_0, POSITIVE_INTEGER106_tree);

			DebugLocation(33, 33);
			LEFT_SHIFT7=(IToken)Match(input,LEFT_SHIFT,Follow._LEFT_SHIFT_in_shift_expression193); 
			LEFT_SHIFT7_tree = (object)adaptor.Create(LEFT_SHIFT7);
			root_0 = (object)adaptor.BecomeRoot(LEFT_SHIFT7_tree, root_0);

			DebugLocation(33, 35);
			POSITIVE_INTEGER108=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression196); 
			POSITIVE_INTEGER108_tree = (object)adaptor.Create(POSITIVE_INTEGER108);
			adaptor.AddChild(root_0, POSITIVE_INTEGER108_tree);


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_expression", 2);
			LeaveRule("shift_expression", 2);
			LeaveRule_shift_expression();
	    }
	 	DebugLocation(33, 53);
		} finally { DebugExitRule(GrammarFileName, "shift_expression"); }
		return retval;

	}
	// $ANTLR end "shift_expression"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_integer_constant() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_integer_constant() {}

	// $ANTLR start "integer_constant"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:35:1: integer_constant : ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 );
	[GrammarRule("integer_constant")]
	private AstParserRuleReturnScope<object, IToken> integer_constant()
	{
		EnterRule_integer_constant();
		EnterRule("integer_constant", 3);
		TraceIn("integer_constant", 3);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken POSITIVE_INTEGER1610 = default(IToken);
	    IToken POSITIVE_INTEGER1011 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> shift_expression9 = default(AstParserRuleReturnScope<object, IToken>);

	    object POSITIVE_INTEGER1610_tree = default(object);
	    object POSITIVE_INTEGER1011_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "integer_constant");
		DebugLocation(35, 62);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:2: ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 )
			int alt1=3;
			try { DebugEnterDecision(1, decisionCanBacktrack[1]);
			int LA1_0 = input.LA(1);

			if ((LA1_0==POSITIVE_INTEGER10))
			{
				int LA1_1 = input.LA(2);

				if ((LA1_1==LEFT_SHIFT))
				{
					alt1 = 1;
				}
				else if ((LA1_1==COMMA||LA1_1==META||LA1_1==RBRACE))
				{
					alt1 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}
			else if ((LA1_0==POSITIVE_INTEGER16))
			{
				alt1 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:4: shift_expression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(36, 4);
				PushFollow(Follow._shift_expression_in_integer_constant209);
				shift_expression9=shift_expression();
				PopFollow();

				adaptor.AddChild(root_0, shift_expression9.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:23: POSITIVE_INTEGER16
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(36, 23);
				POSITIVE_INTEGER1610=(IToken)Match(input,POSITIVE_INTEGER16,Follow._POSITIVE_INTEGER16_in_integer_constant213); 
				POSITIVE_INTEGER1610_tree = (object)adaptor.Create(POSITIVE_INTEGER1610);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1610_tree);


				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:44: POSITIVE_INTEGER10
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(36, 44);
				POSITIVE_INTEGER1011=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_integer_constant217); 
				POSITIVE_INTEGER1011_tree = (object)adaptor.Create(POSITIVE_INTEGER1011);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1011_tree);


				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("integer_constant", 3);
			LeaveRule("integer_constant", 3);
			LeaveRule_integer_constant();
	    }
	 	DebugLocation(36, 62);
		} finally { DebugExitRule(GrammarFileName, "integer_constant"); }
		return retval;

	}
	// $ANTLR end "integer_constant"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_value_assignment() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_value_assignment() {}

	// $ANTLR start "value_assignment"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:1: value_assignment : EQUALS ! integer_constant ;
	[GrammarRule("value_assignment")]
	private AstParserRuleReturnScope<object, IToken> value_assignment()
	{
		EnterRule_value_assignment();
		EnterRule("value_assignment", 4);
		TraceIn("value_assignment", 4);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken EQUALS12 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> integer_constant13 = default(AstParserRuleReturnScope<object, IToken>);

	    object EQUALS12_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "value_assignment");
		DebugLocation(38, 28);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:39:2: ( EQUALS ! integer_constant )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:39:4: EQUALS ! integer_constant
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(39, 10);
			EQUALS12=(IToken)Match(input,EQUALS,Follow._EQUALS_in_value_assignment227); 
			DebugLocation(39, 12);
			PushFollow(Follow._integer_constant_in_value_assignment230);
			integer_constant13=integer_constant();
			PopFollow();

			adaptor.AddChild(root_0, integer_constant13.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_assignment", 4);
			LeaveRule("value_assignment", 4);
			LeaveRule_value_assignment();
	    }
	 	DebugLocation(39, 28);
		} finally { DebugExitRule(GrammarFileName, "value_assignment"); }
		return retval;

	}
	// $ANTLR end "value_assignment"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_last_enum_entry() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_last_enum_entry() {}

	// $ANTLR start "last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:41:1: last_enum_entry : ID ( value_assignment )? ( enum_conversion_tag )? ;
	[GrammarRule("last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> last_enum_entry()
	{
		EnterRule_last_enum_entry();
		EnterRule("last_enum_entry", 5);
		TraceIn("last_enum_entry", 5);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken ID14 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> value_assignment15 = default(AstParserRuleReturnScope<object, IToken>);
	    AstParserRuleReturnScope<object, IToken> enum_conversion_tag16 = default(AstParserRuleReturnScope<object, IToken>);

	    object ID14_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "last_enum_entry");
		DebugLocation(41, 45);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:2: ( ID ( value_assignment )? ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:4: ID ( value_assignment )? ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(42, 4);
			ID14=(IToken)Match(input,ID,Follow._ID_in_last_enum_entry240); 
			ID14_tree = (object)adaptor.Create(ID14);
			adaptor.AddChild(root_0, ID14_tree);

			DebugLocation(42, 7);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:7: ( value_assignment )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, decisionCanBacktrack[2]);
			int LA2_0 = input.LA(1);

			if ((LA2_0==EQUALS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:7: value_assignment
				{
				DebugLocation(42, 7);
				PushFollow(Follow._value_assignment_in_last_enum_entry242);
				value_assignment15=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment15.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(42, 25);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:25: ( enum_conversion_tag )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, decisionCanBacktrack[3]);
			int LA3_0 = input.LA(1);

			if ((LA3_0==META))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:25: enum_conversion_tag
				{
				DebugLocation(42, 25);
				PushFollow(Follow._enum_conversion_tag_in_last_enum_entry245);
				enum_conversion_tag16=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("last_enum_entry", 5);
			LeaveRule("last_enum_entry", 5);
			LeaveRule_last_enum_entry();
	    }
	 	DebugLocation(42, 45);
		} finally { DebugExitRule(GrammarFileName, "last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "last_enum_entry"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_non_last_enum_entry() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_non_last_enum_entry() {}

	// $ANTLR start "non_last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:1: non_last_enum_entry : ID ( value_assignment )? COMMA ! ( enum_conversion_tag )? ;
	[GrammarRule("non_last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> non_last_enum_entry()
	{
		EnterRule_non_last_enum_entry();
		EnterRule("non_last_enum_entry", 6);
		TraceIn("non_last_enum_entry", 6);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken ID17 = default(IToken);
	    IToken COMMA19 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> value_assignment18 = default(AstParserRuleReturnScope<object, IToken>);
	    AstParserRuleReturnScope<object, IToken> enum_conversion_tag20 = default(AstParserRuleReturnScope<object, IToken>);

	    object ID17_tree = default(object);
	    object COMMA19_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "non_last_enum_entry");
		DebugLocation(44, 52);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:2: ( ID ( value_assignment )? COMMA ! ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:4: ID ( value_assignment )? COMMA ! ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(45, 4);
			ID17=(IToken)Match(input,ID,Follow._ID_in_non_last_enum_entry256); 
			ID17_tree = (object)adaptor.Create(ID17);
			adaptor.AddChild(root_0, ID17_tree);

			DebugLocation(45, 7);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:7: ( value_assignment )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, decisionCanBacktrack[4]);
			int LA4_0 = input.LA(1);

			if ((LA4_0==EQUALS))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:7: value_assignment
				{
				DebugLocation(45, 7);
				PushFollow(Follow._value_assignment_in_non_last_enum_entry258);
				value_assignment18=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment18.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(45, 30);
			COMMA19=(IToken)Match(input,COMMA,Follow._COMMA_in_non_last_enum_entry261); 
			DebugLocation(45, 32);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:32: ( enum_conversion_tag )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, decisionCanBacktrack[5]);
			int LA5_0 = input.LA(1);

			if ((LA5_0==META))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:32: enum_conversion_tag
				{
				DebugLocation(45, 32);
				PushFollow(Follow._enum_conversion_tag_in_non_last_enum_entry264);
				enum_conversion_tag20=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag20.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("non_last_enum_entry", 6);
			LeaveRule("non_last_enum_entry", 6);
			LeaveRule_non_last_enum_entry();
	    }
	 	DebugLocation(45, 52);
		} finally { DebugExitRule(GrammarFileName, "non_last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "non_last_enum_entry"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_enum_entry_list() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_enum_entry_list() {}

	// $ANTLR start "enum_entry_list"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:1: enum_entry_list : ( non_last_enum_entry )* last_enum_entry ;
	[GrammarRule("enum_entry_list")]
	private AstParserRuleReturnScope<object, IToken> enum_entry_list()
	{
		EnterRule_enum_entry_list();
		EnterRule("enum_entry_list", 7);
		TraceIn("enum_entry_list", 7);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    AstParserRuleReturnScope<object, IToken> non_last_enum_entry21 = default(AstParserRuleReturnScope<object, IToken>);
	    AstParserRuleReturnScope<object, IToken> last_enum_entry22 = default(AstParserRuleReturnScope<object, IToken>);


		try { DebugEnterRule(GrammarFileName, "enum_entry_list");
		DebugLocation(47, 40);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:2: ( ( non_last_enum_entry )* last_enum_entry )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:4: ( non_last_enum_entry )* last_enum_entry
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(48, 4);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:4: ( non_last_enum_entry )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, decisionCanBacktrack[6]);
				int LA6_0 = input.LA(1);

				if ((LA6_0==ID))
				{
					int LA6_1 = input.LA(2);

					if ((LA6_1==EQUALS))
					{
						int LA6_2 = input.LA(3);

						if ((LA6_2==POSITIVE_INTEGER10))
						{
							int LA6_5 = input.LA(4);

							if ((LA6_5==LEFT_SHIFT))
							{
								int LA6_7 = input.LA(5);

								if ((LA6_7==POSITIVE_INTEGER10))
								{
									int LA6_8 = input.LA(6);

									if ((LA6_8==COMMA))
									{
										alt6 = 1;
									}


								}


							}
							else if ((LA6_5==COMMA))
							{
								alt6 = 1;
							}


						}
						else if ((LA6_2==POSITIVE_INTEGER16))
						{
							int LA6_6 = input.LA(4);

							if ((LA6_6==COMMA))
							{
								alt6 = 1;
							}


						}


					}
					else if ((LA6_1==COMMA))
					{
						alt6 = 1;
					}


				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:4: non_last_enum_entry
					{
					DebugLocation(48, 4);
					PushFollow(Follow._non_last_enum_entry_in_enum_entry_list276);
					non_last_enum_entry21=non_last_enum_entry();
					PopFollow();

					adaptor.AddChild(root_0, non_last_enum_entry21.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(48, 25);
			PushFollow(Follow._last_enum_entry_in_enum_entry_list279);
			last_enum_entry22=last_enum_entry();
			PopFollow();

			adaptor.AddChild(root_0, last_enum_entry22.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_entry_list", 7);
			LeaveRule("enum_entry_list", 7);
			LeaveRule_enum_entry_list();
	    }
	 	DebugLocation(48, 40);
		} finally { DebugExitRule(GrammarFileName, "enum_entry_list"); }
		return retval;

	}
	// $ANTLR end "enum_entry_list"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_enum_definition() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_enum_definition() {}

	// $ANTLR start "enum_definition"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:50:1: enum_definition : ENUM ^ ID LBRACE ! enum_entry_list RBRACE ! SEMICOLON !;
	[GrammarRule("enum_definition")]
	private AstParserRuleReturnScope<object, IToken> enum_definition()
	{
		EnterRule_enum_definition();
		EnterRule("enum_definition", 8);
		TraceIn("enum_definition", 8);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken ENUM23 = default(IToken);
	    IToken ID24 = default(IToken);
	    IToken LBRACE25 = default(IToken);
	    IToken RBRACE27 = default(IToken);
	    IToken SEMICOLON28 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> enum_entry_list26 = default(AstParserRuleReturnScope<object, IToken>);

	    object ENUM23_tree = default(object);
	    object ID24_tree = default(object);
	    object LBRACE25_tree = default(object);
	    object RBRACE27_tree = default(object);
	    object SEMICOLON28_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "enum_definition");
		DebugLocation(50, 55);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:2: ( ENUM ^ ID LBRACE ! enum_entry_list RBRACE ! SEMICOLON !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:4: ENUM ^ ID LBRACE ! enum_entry_list RBRACE ! SEMICOLON !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(51, 8);
			ENUM23=(IToken)Match(input,ENUM,Follow._ENUM_in_enum_definition289); 
			ENUM23_tree = (object)adaptor.Create(ENUM23);
			root_0 = (object)adaptor.BecomeRoot(ENUM23_tree, root_0);

			DebugLocation(51, 10);
			ID24=(IToken)Match(input,ID,Follow._ID_in_enum_definition292); 
			ID24_tree = (object)adaptor.Create(ID24);
			adaptor.AddChild(root_0, ID24_tree);

			DebugLocation(51, 19);
			LBRACE25=(IToken)Match(input,LBRACE,Follow._LBRACE_in_enum_definition294); 
			DebugLocation(51, 21);
			PushFollow(Follow._enum_entry_list_in_enum_definition297);
			enum_entry_list26=enum_entry_list();
			PopFollow();

			adaptor.AddChild(root_0, enum_entry_list26.Tree);
			DebugLocation(51, 43);
			RBRACE27=(IToken)Match(input,RBRACE,Follow._RBRACE_in_enum_definition299); 
			DebugLocation(51, 54);
			SEMICOLON28=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_enum_definition302); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_definition", 8);
			LeaveRule("enum_definition", 8);
			LeaveRule_enum_definition();
	    }
	 	DebugLocation(51, 55);
		} finally { DebugExitRule(GrammarFileName, "enum_definition"); }
		return retval;

	}
	// $ANTLR end "enum_definition"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_enum_properties() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_enum_properties() {}

	// $ANTLR start "enum_properties"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:53:1: enum_properties : BITFIELD ;
	[GrammarRule("enum_properties")]
	private AstParserRuleReturnScope<object, IToken> enum_properties()
	{
		EnterRule_enum_properties();
		EnterRule("enum_properties", 9);
		TraceIn("enum_properties", 9);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken BITFIELD29 = default(IToken);

	    object BITFIELD29_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "enum_properties");
		DebugLocation(53, 12);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:2: ( BITFIELD )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:4: BITFIELD
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(54, 4);
			BITFIELD29=(IToken)Match(input,BITFIELD,Follow._BITFIELD_in_enum_properties313); 
			BITFIELD29_tree = (object)adaptor.Create(BITFIELD29);
			adaptor.AddChild(root_0, BITFIELD29_tree);


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_properties", 9);
			LeaveRule("enum_properties", 9);
			LeaveRule_enum_properties();
	    }
	 	DebugLocation(54, 12);
		} finally { DebugExitRule(GrammarFileName, "enum_properties"); }
		return retval;

	}
	// $ANTLR end "enum_properties"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_enum_begin_meta() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_enum_begin_meta() {}

	// $ANTLR start "enum_begin_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:56:1: enum_begin_meta : META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !;
	[GrammarRule("enum_begin_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_begin_meta()
	{
		EnterRule_enum_begin_meta();
		EnterRule("enum_begin_meta", 10);
		TraceIn("enum_begin_meta", 10);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken META30 = default(IToken);
	    IToken ENUM_BEGIN31 = default(IToken);
	    IToken LPAREN32 = default(IToken);
	    IToken RPAREN34 = default(IToken);
	    AstParserRuleReturnScope<object, IToken> enum_properties33 = default(AstParserRuleReturnScope<object, IToken>);

	    object META30_tree = default(object);
	    object ENUM_BEGIN31_tree = default(object);
	    object LPAREN32_tree = default(object);
	    object RPAREN34_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "enum_begin_meta");
		DebugLocation(56, 54);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:2: ( META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:4: META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(57, 8);
			META30=(IToken)Match(input,META,Follow._META_in_enum_begin_meta324); 
			DebugLocation(57, 20);
			ENUM_BEGIN31=(IToken)Match(input,ENUM_BEGIN,Follow._ENUM_BEGIN_in_enum_begin_meta327); 
			ENUM_BEGIN31_tree = (object)adaptor.Create(ENUM_BEGIN31);
			root_0 = (object)adaptor.BecomeRoot(ENUM_BEGIN31_tree, root_0);

			DebugLocation(57, 28);
			LPAREN32=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_begin_meta330); 
			DebugLocation(57, 30);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:30: ( enum_properties )?
			int alt7=2;
			try { DebugEnterSubRule(7);
			try { DebugEnterDecision(7, decisionCanBacktrack[7]);
			int LA7_0 = input.LA(1);

			if ((LA7_0==BITFIELD))
			{
				alt7 = 1;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:30: enum_properties
				{
				DebugLocation(57, 30);
				PushFollow(Follow._enum_properties_in_enum_begin_meta333);
				enum_properties33=enum_properties();
				PopFollow();

				adaptor.AddChild(root_0, enum_properties33.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(7); }

			DebugLocation(57, 53);
			RPAREN34=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_begin_meta336); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_begin_meta", 10);
			LeaveRule("enum_begin_meta", 10);
			LeaveRule_enum_begin_meta();
	    }
	 	DebugLocation(57, 54);
		} finally { DebugExitRule(GrammarFileName, "enum_begin_meta"); }
		return retval;

	}
	// $ANTLR end "enum_begin_meta"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_enum_end_meta() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_enum_end_meta() {}

	// $ANTLR start "enum_end_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:59:1: enum_end_meta : META ! ENUM_END ^;
	[GrammarRule("enum_end_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_end_meta()
	{
		EnterRule_enum_end_meta();
		EnterRule("enum_end_meta", 11);
		TraceIn("enum_end_meta", 11);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    IToken META35 = default(IToken);
	    IToken ENUM_END36 = default(IToken);

	    object META35_tree = default(object);
	    object ENUM_END36_tree = default(object);

		try { DebugEnterRule(GrammarFileName, "enum_end_meta");
		DebugLocation(59, 19);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:60:2: ( META ! ENUM_END ^)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:60:4: META ! ENUM_END ^
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(60, 8);
			META35=(IToken)Match(input,META,Follow._META_in_enum_end_meta348); 
			DebugLocation(60, 18);
			ENUM_END36=(IToken)Match(input,ENUM_END,Follow._ENUM_END_in_enum_end_meta351); 
			ENUM_END36_tree = (object)adaptor.Create(ENUM_END36);
			root_0 = (object)adaptor.BecomeRoot(ENUM_END36_tree, root_0);


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_end_meta", 11);
			LeaveRule("enum_end_meta", 11);
			LeaveRule_enum_end_meta();
	    }
	 	DebugLocation(60, 19);
		} finally { DebugExitRule(GrammarFileName, "enum_end_meta"); }
		return retval;

	}
	// $ANTLR end "enum_end_meta"


	[Conditional("ANTLR_TRACE")]
	protected virtual void EnterRule_top_rule() {}
	[Conditional("ANTLR_TRACE")]
	protected virtual void LeaveRule_top_rule() {}

	// $ANTLR start "top_rule"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:62:1: top_rule : enum_begin_meta enum_definition enum_end_meta ;
	[GrammarRule("top_rule")]
	private AstParserRuleReturnScope<object, IToken> top_rule()
	{
		EnterRule_top_rule();
		EnterRule("top_rule", 12);
		TraceIn("top_rule", 12);
	    AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
	    retval.Start = (IToken)input.LT(1);

	    object root_0 = default(object);

	    AstParserRuleReturnScope<object, IToken> enum_begin_meta37 = default(AstParserRuleReturnScope<object, IToken>);
	    AstParserRuleReturnScope<object, IToken> enum_definition38 = default(AstParserRuleReturnScope<object, IToken>);
	    AstParserRuleReturnScope<object, IToken> enum_end_meta39 = default(AstParserRuleReturnScope<object, IToken>);


		try { DebugEnterRule(GrammarFileName, "top_rule");
		DebugLocation(62, 49);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:63:2: ( enum_begin_meta enum_definition enum_end_meta )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:63:4: enum_begin_meta enum_definition enum_end_meta
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(63, 4);
			PushFollow(Follow._enum_begin_meta_in_top_rule362);
			enum_begin_meta37=enum_begin_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_begin_meta37.Tree);
			DebugLocation(63, 20);
			PushFollow(Follow._enum_definition_in_top_rule364);
			enum_definition38=enum_definition();
			PopFollow();

			adaptor.AddChild(root_0, enum_definition38.Tree);
			DebugLocation(63, 36);
			PushFollow(Follow._enum_end_meta_in_top_rule366);
			enum_end_meta39=enum_end_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_end_meta39.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("top_rule", 12);
			LeaveRule("top_rule", 12);
			LeaveRule_top_rule();
	    }
	 	DebugLocation(63, 49);
		} finally { DebugExitRule(GrammarFileName, "top_rule"); }
		return retval;

	}
	// $ANTLR end "top_rule"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _META_in_enum_conversion_tag169 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ENUM_ENTRY_in_enum_conversion_tag172 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _LPAREN_in_enum_conversion_tag175 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _STRING_in_enum_conversion_tag178 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _RPAREN_in_enum_conversion_tag180 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression191 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _LEFT_SHIFT_in_shift_expression193 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression196 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_expression_in_integer_constant209 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER16_in_integer_constant213 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_integer_constant217 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQUALS_in_value_assignment227 = new BitSet(new ulong[]{0xC0000UL});
		public static readonly BitSet _integer_constant_in_value_assignment230 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_last_enum_entry240 = new BitSet(new ulong[]{0x20802UL});
		public static readonly BitSet _value_assignment_in_last_enum_entry242 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _enum_conversion_tag_in_last_enum_entry245 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_non_last_enum_entry256 = new BitSet(new ulong[]{0x820UL});
		public static readonly BitSet _value_assignment_in_non_last_enum_entry258 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_non_last_enum_entry261 = new BitSet(new ulong[]{0x20002UL});
		public static readonly BitSet _enum_conversion_tag_in_non_last_enum_entry264 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _non_last_enum_entry_in_enum_entry_list276 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _last_enum_entry_in_enum_entry_list279 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ENUM_in_enum_definition289 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _ID_in_enum_definition292 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _LBRACE_in_enum_definition294 = new BitSet(new ulong[]{0x2000UL});
		public static readonly BitSet _enum_entry_list_in_enum_definition297 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _RBRACE_in_enum_definition299 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _SEMICOLON_in_enum_definition302 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BITFIELD_in_enum_properties313 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_begin_meta324 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ENUM_BEGIN_in_enum_begin_meta327 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _LPAREN_in_enum_begin_meta330 = new BitSet(new ulong[]{0x400010UL});
		public static readonly BitSet _enum_properties_in_enum_begin_meta333 = new BitSet(new ulong[]{0x400000UL});
		public static readonly BitSet _RPAREN_in_enum_begin_meta336 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_end_meta348 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ENUM_END_in_enum_end_meta351 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enum_begin_meta_in_top_rule362 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _enum_definition_in_top_rule364 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _enum_end_meta_in_top_rule366 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
