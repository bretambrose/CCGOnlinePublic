//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g 2012-12-02 14:50:15

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
public partial class EnumReflectorParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BITFIELD", "COMMA", "DIGIT", "ENUM", "ENUM_BEGIN", "ENUM_END", "ENUM_ENTRY", "EQUALS", "EXTENDS", "HEX_DIGIT", "ID", "LBRACE", "LEFT_SHIFT", "LPAREN", "META", "NAMESPACE", "POSITIVE_INTEGER10", "POSITIVE_INTEGER16", "POS_DIGIT", "RBRACE", "RPAREN", "SEMICOLON", "STRING", "WHITESPACE"
	};
	public const int EOF=-1;
	public const int BITFIELD=4;
	public const int COMMA=5;
	public const int DIGIT=6;
	public const int ENUM=7;
	public const int ENUM_BEGIN=8;
	public const int ENUM_END=9;
	public const int ENUM_ENTRY=10;
	public const int EQUALS=11;
	public const int EXTENDS=12;
	public const int HEX_DIGIT=13;
	public const int ID=14;
	public const int LBRACE=15;
	public const int LEFT_SHIFT=16;
	public const int LPAREN=17;
	public const int META=18;
	public const int NAMESPACE=19;
	public const int POSITIVE_INTEGER10=20;
	public const int POSITIVE_INTEGER16=21;
	public const int POS_DIGIT=22;
	public const int RBRACE=23;
	public const int RPAREN=24;
	public const int SEMICOLON=25;
	public const int STRING=26;
	public const int WHITESPACE=27;

	public EnumReflectorParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public EnumReflectorParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return EnumReflectorParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_enum_conversion_tag();
	partial void LeaveRule_enum_conversion_tag();

	// $ANTLR start "enum_conversion_tag"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:31:1: enum_conversion_tag : META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !;
	[GrammarRule("enum_conversion_tag")]
	private AstParserRuleReturnScope<object, IToken> enum_conversion_tag()
	{
		EnterRule_enum_conversion_tag();
		EnterRule("enum_conversion_tag", 1);
		TraceIn("enum_conversion_tag", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META1 = default(IToken);
		IToken ENUM_ENTRY2 = default(IToken);
		IToken LPAREN3 = default(IToken);
		IToken STRING4 = default(IToken);
		IToken RPAREN5 = default(IToken);

		object META1_tree = default(object);
		object ENUM_ENTRY2_tree = default(object);
		object LPAREN3_tree = default(object);
		object STRING4_tree = default(object);
		object RPAREN5_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_conversion_tag");
		DebugLocation(31, 44);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:32:2: ( META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:32:4: META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(32, 8);
			META1=(IToken)Match(input,META,Follow._META_in_enum_conversion_tag187); 
			DebugLocation(32, 20);
			ENUM_ENTRY2=(IToken)Match(input,ENUM_ENTRY,Follow._ENUM_ENTRY_in_enum_conversion_tag190); 
			ENUM_ENTRY2_tree = (object)adaptor.Create(ENUM_ENTRY2);
			root_0 = (object)adaptor.BecomeRoot(ENUM_ENTRY2_tree, root_0);
			DebugLocation(32, 28);
			LPAREN3=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_conversion_tag193); 
			DebugLocation(32, 30);
			STRING4=(IToken)Match(input,STRING,Follow._STRING_in_enum_conversion_tag196); 
			STRING4_tree = (object)adaptor.Create(STRING4);
			adaptor.AddChild(root_0, STRING4_tree);
			DebugLocation(32, 43);
			RPAREN5=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_conversion_tag198); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_conversion_tag", 1);
			LeaveRule("enum_conversion_tag", 1);
			LeaveRule_enum_conversion_tag();
		}
		DebugLocation(32, 44);
		} finally { DebugExitRule(GrammarFileName, "enum_conversion_tag"); }
		return retval;

	}
	// $ANTLR end "enum_conversion_tag"

	partial void EnterRule_shift_expression();
	partial void LeaveRule_shift_expression();

	// $ANTLR start "shift_expression"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:34:1: shift_expression : POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 ;
	[GrammarRule("shift_expression")]
	private AstParserRuleReturnScope<object, IToken> shift_expression()
	{
		EnterRule_shift_expression();
		EnterRule("shift_expression", 2);
		TraceIn("shift_expression", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken POSITIVE_INTEGER106 = default(IToken);
		IToken LEFT_SHIFT7 = default(IToken);
		IToken POSITIVE_INTEGER108 = default(IToken);

		object POSITIVE_INTEGER106_tree = default(object);
		object LEFT_SHIFT7_tree = default(object);
		object POSITIVE_INTEGER108_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "shift_expression");
		DebugLocation(34, 53);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:35:2: ( POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:35:4: POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(35, 4);
			POSITIVE_INTEGER106=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression209); 
			POSITIVE_INTEGER106_tree = (object)adaptor.Create(POSITIVE_INTEGER106);
			adaptor.AddChild(root_0, POSITIVE_INTEGER106_tree);
			DebugLocation(35, 33);
			LEFT_SHIFT7=(IToken)Match(input,LEFT_SHIFT,Follow._LEFT_SHIFT_in_shift_expression211); 
			LEFT_SHIFT7_tree = (object)adaptor.Create(LEFT_SHIFT7);
			root_0 = (object)adaptor.BecomeRoot(LEFT_SHIFT7_tree, root_0);
			DebugLocation(35, 35);
			POSITIVE_INTEGER108=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression214); 
			POSITIVE_INTEGER108_tree = (object)adaptor.Create(POSITIVE_INTEGER108);
			adaptor.AddChild(root_0, POSITIVE_INTEGER108_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_expression", 2);
			LeaveRule("shift_expression", 2);
			LeaveRule_shift_expression();
		}
		DebugLocation(35, 53);
		} finally { DebugExitRule(GrammarFileName, "shift_expression"); }
		return retval;

	}
	// $ANTLR end "shift_expression"

	partial void EnterRule_integer_constant();
	partial void LeaveRule_integer_constant();

	// $ANTLR start "integer_constant"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:37:1: integer_constant : ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 | ID );
	[GrammarRule("integer_constant")]
	private AstParserRuleReturnScope<object, IToken> integer_constant()
	{
		EnterRule_integer_constant();
		EnterRule("integer_constant", 3);
		TraceIn("integer_constant", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken POSITIVE_INTEGER1610 = default(IToken);
		IToken POSITIVE_INTEGER1011 = default(IToken);
		IToken ID12 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shift_expression9 = default(AstParserRuleReturnScope<object, IToken>);

		object POSITIVE_INTEGER1610_tree = default(object);
		object POSITIVE_INTEGER1011_tree = default(object);
		object ID12_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "integer_constant");
		DebugLocation(37, 66);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:2: ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 | ID )
			int alt1=4;
			try { DebugEnterDecision(1, false);
			switch (input.LA(1))
			{
			case POSITIVE_INTEGER10:
				{
				int LA1_1 = input.LA(2);

				if ((LA1_1==LEFT_SHIFT))
				{
					alt1 = 1;
				}
				else if ((LA1_1==COMMA||LA1_1==META||LA1_1==RBRACE))
				{
					alt1 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case POSITIVE_INTEGER16:
				{
				alt1 = 2;
				}
				break;
			case ID:
				{
				alt1 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 1, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(1); }
			switch (alt1)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:4: shift_expression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(38, 4);
				PushFollow(Follow._shift_expression_in_integer_constant227);
				shift_expression9=shift_expression();
				PopFollow();

				adaptor.AddChild(root_0, shift_expression9.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:23: POSITIVE_INTEGER16
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(38, 23);
				POSITIVE_INTEGER1610=(IToken)Match(input,POSITIVE_INTEGER16,Follow._POSITIVE_INTEGER16_in_integer_constant231); 
				POSITIVE_INTEGER1610_tree = (object)adaptor.Create(POSITIVE_INTEGER1610);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1610_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:44: POSITIVE_INTEGER10
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(38, 44);
				POSITIVE_INTEGER1011=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_integer_constant235); 
				POSITIVE_INTEGER1011_tree = (object)adaptor.Create(POSITIVE_INTEGER1011);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1011_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:65: ID
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(38, 65);
				ID12=(IToken)Match(input,ID,Follow._ID_in_integer_constant239); 
				ID12_tree = (object)adaptor.Create(ID12);
				adaptor.AddChild(root_0, ID12_tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("integer_constant", 3);
			LeaveRule("integer_constant", 3);
			LeaveRule_integer_constant();
		}
		DebugLocation(38, 66);
		} finally { DebugExitRule(GrammarFileName, "integer_constant"); }
		return retval;

	}
	// $ANTLR end "integer_constant"

	partial void EnterRule_value_assignment();
	partial void LeaveRule_value_assignment();

	// $ANTLR start "value_assignment"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:40:1: value_assignment : EQUALS ! integer_constant ;
	[GrammarRule("value_assignment")]
	private AstParserRuleReturnScope<object, IToken> value_assignment()
	{
		EnterRule_value_assignment();
		EnterRule("value_assignment", 4);
		TraceIn("value_assignment", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUALS13 = default(IToken);
		AstParserRuleReturnScope<object, IToken> integer_constant14 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUALS13_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_assignment");
		DebugLocation(40, 28);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:41:2: ( EQUALS ! integer_constant )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:41:4: EQUALS ! integer_constant
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(41, 10);
			EQUALS13=(IToken)Match(input,EQUALS,Follow._EQUALS_in_value_assignment248); 
			DebugLocation(41, 12);
			PushFollow(Follow._integer_constant_in_value_assignment251);
			integer_constant14=integer_constant();
			PopFollow();

			adaptor.AddChild(root_0, integer_constant14.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_assignment", 4);
			LeaveRule("value_assignment", 4);
			LeaveRule_value_assignment();
		}
		DebugLocation(41, 28);
		} finally { DebugExitRule(GrammarFileName, "value_assignment"); }
		return retval;

	}
	// $ANTLR end "value_assignment"

	partial void EnterRule_last_enum_entry();
	partial void LeaveRule_last_enum_entry();

	// $ANTLR start "last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:43:1: last_enum_entry : ID ^ ( value_assignment )? ( enum_conversion_tag )? ;
	[GrammarRule("last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> last_enum_entry()
	{
		EnterRule_last_enum_entry();
		EnterRule("last_enum_entry", 5);
		TraceIn("last_enum_entry", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID15 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_assignment16 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_conversion_tag17 = default(AstParserRuleReturnScope<object, IToken>);

		object ID15_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "last_enum_entry");
		DebugLocation(43, 46);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:2: ( ID ^ ( value_assignment )? ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:4: ID ^ ( value_assignment )? ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(44, 6);
			ID15=(IToken)Match(input,ID,Follow._ID_in_last_enum_entry261); 
			ID15_tree = (object)adaptor.Create(ID15);
			root_0 = (object)adaptor.BecomeRoot(ID15_tree, root_0);
			DebugLocation(44, 8);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:8: ( value_assignment )?
			int alt2=2;
			try { DebugEnterSubRule(2);
			try { DebugEnterDecision(2, false);
			int LA2_0 = input.LA(1);

			if ((LA2_0==EQUALS))
			{
				alt2 = 1;
			}
			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:8: value_assignment
				{
				DebugLocation(44, 8);
				PushFollow(Follow._value_assignment_in_last_enum_entry264);
				value_assignment16=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment16.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(2); }

			DebugLocation(44, 26);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:26: ( enum_conversion_tag )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==META))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:26: enum_conversion_tag
				{
				DebugLocation(44, 26);
				PushFollow(Follow._enum_conversion_tag_in_last_enum_entry267);
				enum_conversion_tag17=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag17.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("last_enum_entry", 5);
			LeaveRule("last_enum_entry", 5);
			LeaveRule_last_enum_entry();
		}
		DebugLocation(44, 46);
		} finally { DebugExitRule(GrammarFileName, "last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "last_enum_entry"

	partial void EnterRule_non_last_enum_entry();
	partial void LeaveRule_non_last_enum_entry();

	// $ANTLR start "non_last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:46:1: non_last_enum_entry : ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )? ;
	[GrammarRule("non_last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> non_last_enum_entry()
	{
		EnterRule_non_last_enum_entry();
		EnterRule("non_last_enum_entry", 6);
		TraceIn("non_last_enum_entry", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID18 = default(IToken);
		IToken COMMA20 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_assignment19 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_conversion_tag21 = default(AstParserRuleReturnScope<object, IToken>);

		object ID18_tree = default(object);
		object COMMA20_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "non_last_enum_entry");
		DebugLocation(46, 53);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:2: ( ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:4: ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(47, 6);
			ID18=(IToken)Match(input,ID,Follow._ID_in_non_last_enum_entry278); 
			ID18_tree = (object)adaptor.Create(ID18);
			root_0 = (object)adaptor.BecomeRoot(ID18_tree, root_0);
			DebugLocation(47, 8);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:8: ( value_assignment )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==EQUALS))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:8: value_assignment
				{
				DebugLocation(47, 8);
				PushFollow(Follow._value_assignment_in_non_last_enum_entry281);
				value_assignment19=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment19.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }

			DebugLocation(47, 31);
			COMMA20=(IToken)Match(input,COMMA,Follow._COMMA_in_non_last_enum_entry284); 
			DebugLocation(47, 33);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:33: ( enum_conversion_tag )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==META))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:33: enum_conversion_tag
				{
				DebugLocation(47, 33);
				PushFollow(Follow._enum_conversion_tag_in_non_last_enum_entry287);
				enum_conversion_tag21=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag21.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("non_last_enum_entry", 6);
			LeaveRule("non_last_enum_entry", 6);
			LeaveRule_non_last_enum_entry();
		}
		DebugLocation(47, 53);
		} finally { DebugExitRule(GrammarFileName, "non_last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "non_last_enum_entry"

	partial void EnterRule_enum_entry_list();
	partial void LeaveRule_enum_entry_list();

	// $ANTLR start "enum_entry_list"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:49:1: enum_entry_list : LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !;
	[GrammarRule("enum_entry_list")]
	private AstParserRuleReturnScope<object, IToken> enum_entry_list()
	{
		EnterRule_enum_entry_list();
		EnterRule("enum_entry_list", 7);
		TraceIn("enum_entry_list", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACE22 = default(IToken);
		IToken RBRACE25 = default(IToken);
		AstParserRuleReturnScope<object, IToken> non_last_enum_entry23 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> last_enum_entry24 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACE22_tree = default(object);
		object RBRACE25_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_entry_list");
		DebugLocation(49, 57);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:50:2: ( LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:50:4: LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(50, 10);
			LBRACE22=(IToken)Match(input,LBRACE,Follow._LBRACE_in_enum_entry_list299); 
			LBRACE22_tree = (object)adaptor.Create(LBRACE22);
			root_0 = (object)adaptor.BecomeRoot(LBRACE22_tree, root_0);
			DebugLocation(50, 12);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:50:12: ( non_last_enum_entry )*
			try { DebugEnterSubRule(6);
			while (true)
			{
				int alt6=2;
				try { DebugEnterDecision(6, false);
				int LA6_0 = input.LA(1);

				if ((LA6_0==ID))
				{
					int LA6_1 = input.LA(2);

					if ((LA6_1==EQUALS))
					{
						switch (input.LA(3))
						{
						case POSITIVE_INTEGER10:
							{
							int LA6_5 = input.LA(4);

							if ((LA6_5==LEFT_SHIFT))
							{
								int LA6_8 = input.LA(5);

								if ((LA6_8==POSITIVE_INTEGER10))
								{
									int LA6_9 = input.LA(6);

									if ((LA6_9==COMMA))
									{
										alt6 = 1;
									}


								}


							}
							else if ((LA6_5==COMMA))
							{
								alt6 = 1;
							}


							}
							break;
						case POSITIVE_INTEGER16:
							{
							int LA6_6 = input.LA(4);

							if ((LA6_6==COMMA))
							{
								alt6 = 1;
							}


							}
							break;
						case ID:
							{
							int LA6_7 = input.LA(4);

							if ((LA6_7==COMMA))
							{
								alt6 = 1;
							}


							}
							break;
						}

					}
					else if ((LA6_1==COMMA))
					{
						alt6 = 1;
					}


				}


				} finally { DebugExitDecision(6); }
				switch ( alt6 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:50:12: non_last_enum_entry
					{
					DebugLocation(50, 12);
					PushFollow(Follow._non_last_enum_entry_in_enum_entry_list302);
					non_last_enum_entry23=non_last_enum_entry();
					PopFollow();

					adaptor.AddChild(root_0, non_last_enum_entry23.Tree);

					}
					break;

				default:
					goto loop6;
				}
			}

			loop6:
				;

			} finally { DebugExitSubRule(6); }

			DebugLocation(50, 33);
			PushFollow(Follow._last_enum_entry_in_enum_entry_list305);
			last_enum_entry24=last_enum_entry();
			PopFollow();

			adaptor.AddChild(root_0, last_enum_entry24.Tree);
			DebugLocation(50, 56);
			RBRACE25=(IToken)Match(input,RBRACE,Follow._RBRACE_in_enum_entry_list308); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_entry_list", 7);
			LeaveRule("enum_entry_list", 7);
			LeaveRule_enum_entry_list();
		}
		DebugLocation(50, 57);
		} finally { DebugExitRule(GrammarFileName, "enum_entry_list"); }
		return retval;

	}
	// $ANTLR end "enum_entry_list"

	partial void EnterRule_extends_clause();
	partial void LeaveRule_extends_clause();

	// $ANTLR start "extends_clause"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:52:1: extends_clause : EXTENDS ^ ID ;
	[GrammarRule("extends_clause")]
	private AstParserRuleReturnScope<object, IToken> extends_clause()
	{
		EnterRule_extends_clause();
		EnterRule("extends_clause", 8);
		TraceIn("extends_clause", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EXTENDS26 = default(IToken);
		IToken ID27 = default(IToken);

		object EXTENDS26_tree = default(object);
		object ID27_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "extends_clause");
		DebugLocation(52, 15);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:53:2: ( EXTENDS ^ ID )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:53:4: EXTENDS ^ ID
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(53, 11);
			EXTENDS26=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_extends_clause319); 
			EXTENDS26_tree = (object)adaptor.Create(EXTENDS26);
			root_0 = (object)adaptor.BecomeRoot(EXTENDS26_tree, root_0);
			DebugLocation(53, 13);
			ID27=(IToken)Match(input,ID,Follow._ID_in_extends_clause322); 
			ID27_tree = (object)adaptor.Create(ID27);
			adaptor.AddChild(root_0, ID27_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("extends_clause", 8);
			LeaveRule("extends_clause", 8);
			LeaveRule_extends_clause();
		}
		DebugLocation(53, 15);
		} finally { DebugExitRule(GrammarFileName, "extends_clause"); }
		return retval;

	}
	// $ANTLR end "extends_clause"

	partial void EnterRule_enum_properties();
	partial void LeaveRule_enum_properties();

	// $ANTLR start "enum_properties"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:55:1: enum_properties : ( BITFIELD | extends_clause );
	[GrammarRule("enum_properties")]
	private AstParserRuleReturnScope<object, IToken> enum_properties()
	{
		EnterRule_enum_properties();
		EnterRule("enum_properties", 9);
		TraceIn("enum_properties", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BITFIELD28 = default(IToken);
		AstParserRuleReturnScope<object, IToken> extends_clause29 = default(AstParserRuleReturnScope<object, IToken>);

		object BITFIELD28_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_properties");
		DebugLocation(55, 29);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:56:2: ( BITFIELD | extends_clause )
			int alt7=2;
			try { DebugEnterDecision(7, false);
			int LA7_0 = input.LA(1);

			if ((LA7_0==BITFIELD))
			{
				alt7 = 1;
			}
			else if ((LA7_0==EXTENDS))
			{
				alt7 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 7, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(7); }
			switch (alt7)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:56:4: BITFIELD
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(56, 4);
				BITFIELD28=(IToken)Match(input,BITFIELD,Follow._BITFIELD_in_enum_properties333); 
				BITFIELD28_tree = (object)adaptor.Create(BITFIELD28);
				adaptor.AddChild(root_0, BITFIELD28_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:56:15: extends_clause
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(56, 15);
				PushFollow(Follow._extends_clause_in_enum_properties337);
				extends_clause29=extends_clause();
				PopFollow();

				adaptor.AddChild(root_0, extends_clause29.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_properties", 9);
			LeaveRule("enum_properties", 9);
			LeaveRule_enum_properties();
		}
		DebugLocation(56, 29);
		} finally { DebugExitRule(GrammarFileName, "enum_properties"); }
		return retval;

	}
	// $ANTLR end "enum_properties"

	partial void EnterRule_enum_begin_meta();
	partial void LeaveRule_enum_begin_meta();

	// $ANTLR start "enum_begin_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:58:1: enum_begin_meta : META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !;
	[GrammarRule("enum_begin_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_begin_meta()
	{
		EnterRule_enum_begin_meta();
		EnterRule("enum_begin_meta", 10);
		TraceIn("enum_begin_meta", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META30 = default(IToken);
		IToken ENUM_BEGIN31 = default(IToken);
		IToken LPAREN32 = default(IToken);
		IToken RPAREN34 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enum_properties33 = default(AstParserRuleReturnScope<object, IToken>);

		object META30_tree = default(object);
		object ENUM_BEGIN31_tree = default(object);
		object LPAREN32_tree = default(object);
		object RPAREN34_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_begin_meta");
		DebugLocation(58, 54);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:59:2: ( META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:59:4: META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(59, 8);
			META30=(IToken)Match(input,META,Follow._META_in_enum_begin_meta348); 
			DebugLocation(59, 20);
			ENUM_BEGIN31=(IToken)Match(input,ENUM_BEGIN,Follow._ENUM_BEGIN_in_enum_begin_meta351); 
			ENUM_BEGIN31_tree = (object)adaptor.Create(ENUM_BEGIN31);
			root_0 = (object)adaptor.BecomeRoot(ENUM_BEGIN31_tree, root_0);
			DebugLocation(59, 28);
			LPAREN32=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_begin_meta354); 
			DebugLocation(59, 30);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:59:30: ( enum_properties )?
			int alt8=2;
			try { DebugEnterSubRule(8);
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==BITFIELD||LA8_0==EXTENDS))
			{
				alt8 = 1;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:59:30: enum_properties
				{
				DebugLocation(59, 30);
				PushFollow(Follow._enum_properties_in_enum_begin_meta357);
				enum_properties33=enum_properties();
				PopFollow();

				adaptor.AddChild(root_0, enum_properties33.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(8); }

			DebugLocation(59, 53);
			RPAREN34=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_begin_meta360); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_begin_meta", 10);
			LeaveRule("enum_begin_meta", 10);
			LeaveRule_enum_begin_meta();
		}
		DebugLocation(59, 54);
		} finally { DebugExitRule(GrammarFileName, "enum_begin_meta"); }
		return retval;

	}
	// $ANTLR end "enum_begin_meta"

	partial void EnterRule_enum_end_meta();
	partial void LeaveRule_enum_end_meta();

	// $ANTLR start "enum_end_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:61:1: enum_end_meta : META ! ENUM_END ^;
	[GrammarRule("enum_end_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_end_meta()
	{
		EnterRule_enum_end_meta();
		EnterRule("enum_end_meta", 11);
		TraceIn("enum_end_meta", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META35 = default(IToken);
		IToken ENUM_END36 = default(IToken);

		object META35_tree = default(object);
		object ENUM_END36_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_end_meta");
		DebugLocation(61, 19);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:62:2: ( META ! ENUM_END ^)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:62:4: META ! ENUM_END ^
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(62, 8);
			META35=(IToken)Match(input,META,Follow._META_in_enum_end_meta372); 
			DebugLocation(62, 18);
			ENUM_END36=(IToken)Match(input,ENUM_END,Follow._ENUM_END_in_enum_end_meta375); 
			ENUM_END36_tree = (object)adaptor.Create(ENUM_END36);
			root_0 = (object)adaptor.BecomeRoot(ENUM_END36_tree, root_0);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_end_meta", 11);
			LeaveRule("enum_end_meta", 11);
			LeaveRule_enum_end_meta();
		}
		DebugLocation(62, 19);
		} finally { DebugExitRule(GrammarFileName, "enum_end_meta"); }
		return retval;

	}
	// $ANTLR end "enum_end_meta"

	partial void EnterRule_enum_definition();
	partial void LeaveRule_enum_definition();

	// $ANTLR start "enum_definition"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:64:1: enum_definition : ENUM ^ ID enum_entry_list SEMICOLON !;
	[GrammarRule("enum_definition")]
	private AstParserRuleReturnScope<object, IToken> enum_definition()
	{
		EnterRule_enum_definition();
		EnterRule("enum_definition", 12);
		TraceIn("enum_definition", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ENUM37 = default(IToken);
		IToken ID38 = default(IToken);
		IToken SEMICOLON40 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enum_entry_list39 = default(AstParserRuleReturnScope<object, IToken>);

		object ENUM37_tree = default(object);
		object ID38_tree = default(object);
		object SEMICOLON40_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_definition");
		DebugLocation(64, 39);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:65:2: ( ENUM ^ ID enum_entry_list SEMICOLON !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:65:4: ENUM ^ ID enum_entry_list SEMICOLON !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(65, 8);
			ENUM37=(IToken)Match(input,ENUM,Follow._ENUM_in_enum_definition386); 
			ENUM37_tree = (object)adaptor.Create(ENUM37);
			root_0 = (object)adaptor.BecomeRoot(ENUM37_tree, root_0);
			DebugLocation(65, 10);
			ID38=(IToken)Match(input,ID,Follow._ID_in_enum_definition389); 
			ID38_tree = (object)adaptor.Create(ID38);
			adaptor.AddChild(root_0, ID38_tree);
			DebugLocation(65, 13);
			PushFollow(Follow._enum_entry_list_in_enum_definition391);
			enum_entry_list39=enum_entry_list();
			PopFollow();

			adaptor.AddChild(root_0, enum_entry_list39.Tree);
			DebugLocation(65, 38);
			SEMICOLON40=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_enum_definition393); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_definition", 12);
			LeaveRule("enum_definition", 12);
			LeaveRule_enum_definition();
		}
		DebugLocation(65, 39);
		} finally { DebugExitRule(GrammarFileName, "enum_definition"); }
		return retval;

	}
	// $ANTLR end "enum_definition"

	partial void EnterRule_namespace_wrapper();
	partial void LeaveRule_namespace_wrapper();

	// $ANTLR start "namespace_wrapper"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:67:1: namespace_wrapper : NAMESPACE ^ ID LBRACE ! enum_definition RBRACE !;
	[GrammarRule("namespace_wrapper")]
	private AstParserRuleReturnScope<object, IToken> namespace_wrapper()
	{
		EnterRule_namespace_wrapper();
		EnterRule("namespace_wrapper", 13);
		TraceIn("namespace_wrapper", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NAMESPACE41 = default(IToken);
		IToken ID42 = default(IToken);
		IToken LBRACE43 = default(IToken);
		IToken RBRACE45 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enum_definition44 = default(AstParserRuleReturnScope<object, IToken>);

		object NAMESPACE41_tree = default(object);
		object ID42_tree = default(object);
		object LBRACE43_tree = default(object);
		object RBRACE45_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "namespace_wrapper");
		DebugLocation(67, 49);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:68:2: ( NAMESPACE ^ ID LBRACE ! enum_definition RBRACE !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:68:4: NAMESPACE ^ ID LBRACE ! enum_definition RBRACE !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(68, 13);
			NAMESPACE41=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_namespace_wrapper405); 
			NAMESPACE41_tree = (object)adaptor.Create(NAMESPACE41);
			root_0 = (object)adaptor.BecomeRoot(NAMESPACE41_tree, root_0);
			DebugLocation(68, 15);
			ID42=(IToken)Match(input,ID,Follow._ID_in_namespace_wrapper408); 
			ID42_tree = (object)adaptor.Create(ID42);
			adaptor.AddChild(root_0, ID42_tree);
			DebugLocation(68, 24);
			LBRACE43=(IToken)Match(input,LBRACE,Follow._LBRACE_in_namespace_wrapper410); 
			DebugLocation(68, 26);
			PushFollow(Follow._enum_definition_in_namespace_wrapper413);
			enum_definition44=enum_definition();
			PopFollow();

			adaptor.AddChild(root_0, enum_definition44.Tree);
			DebugLocation(68, 48);
			RBRACE45=(IToken)Match(input,RBRACE,Follow._RBRACE_in_namespace_wrapper415); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("namespace_wrapper", 13);
			LeaveRule("namespace_wrapper", 13);
			LeaveRule_namespace_wrapper();
		}
		DebugLocation(68, 49);
		} finally { DebugExitRule(GrammarFileName, "namespace_wrapper"); }
		return retval;

	}
	// $ANTLR end "namespace_wrapper"

	partial void EnterRule_enum_entry_point();
	partial void LeaveRule_enum_entry_point();

	// $ANTLR start "enum_entry_point"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:70:1: enum_entry_point : ( namespace_wrapper | enum_definition );
	[GrammarRule("enum_entry_point")]
	private AstParserRuleReturnScope<object, IToken> enum_entry_point()
	{
		EnterRule_enum_entry_point();
		EnterRule("enum_entry_point", 14);
		TraceIn("enum_entry_point", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> namespace_wrapper46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_definition47 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "enum_entry_point");
		DebugLocation(70, 39);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:71:2: ( namespace_wrapper | enum_definition )
			int alt9=2;
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==NAMESPACE))
			{
				alt9 = 1;
			}
			else if ((LA9_0==ENUM))
			{
				alt9 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 9, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:71:4: namespace_wrapper
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(71, 4);
				PushFollow(Follow._namespace_wrapper_in_enum_entry_point427);
				namespace_wrapper46=namespace_wrapper();
				PopFollow();

				adaptor.AddChild(root_0, namespace_wrapper46.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:71:24: enum_definition
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(71, 24);
				PushFollow(Follow._enum_definition_in_enum_entry_point431);
				enum_definition47=enum_definition();
				PopFollow();

				adaptor.AddChild(root_0, enum_definition47.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_entry_point", 14);
			LeaveRule("enum_entry_point", 14);
			LeaveRule_enum_entry_point();
		}
		DebugLocation(71, 39);
		} finally { DebugExitRule(GrammarFileName, "enum_entry_point"); }
		return retval;

	}
	// $ANTLR end "enum_entry_point"

	partial void EnterRule_parse();
	partial void LeaveRule_parse();

	// $ANTLR start "parse"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:73:8: public parse : enum_begin_meta enum_entry_point enum_end_meta ;
	[GrammarRule("parse")]
	public AstParserRuleReturnScope<object, IToken> parse()
	{
		EnterRule_parse();
		EnterRule("parse", 15);
		TraceIn("parse", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> enum_begin_meta48 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_entry_point49 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_end_meta50 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "parse");
		DebugLocation(73, 50);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:74:2: ( enum_begin_meta enum_entry_point enum_end_meta )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:74:4: enum_begin_meta enum_entry_point enum_end_meta
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(74, 4);
			PushFollow(Follow._enum_begin_meta_in_parse446);
			enum_begin_meta48=enum_begin_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_begin_meta48.Tree);
			DebugLocation(74, 20);
			PushFollow(Follow._enum_entry_point_in_parse448);
			enum_entry_point49=enum_entry_point();
			PopFollow();

			adaptor.AddChild(root_0, enum_entry_point49.Tree);
			DebugLocation(74, 37);
			PushFollow(Follow._enum_end_meta_in_parse450);
			enum_end_meta50=enum_end_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_end_meta50.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parse", 15);
			LeaveRule("parse", 15);
			LeaveRule_parse();
		}
		DebugLocation(74, 50);
		} finally { DebugExitRule(GrammarFileName, "parse"); }
		return retval;

	}
	// $ANTLR end "parse"
	#endregion Rules


	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _META_in_enum_conversion_tag187 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ENUM_ENTRY_in_enum_conversion_tag190 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _LPAREN_in_enum_conversion_tag193 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _STRING_in_enum_conversion_tag196 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _RPAREN_in_enum_conversion_tag198 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression209 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _LEFT_SHIFT_in_shift_expression211 = new BitSet(new ulong[]{0x100000UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression214 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_expression_in_integer_constant227 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER16_in_integer_constant231 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_integer_constant235 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_integer_constant239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQUALS_in_value_assignment248 = new BitSet(new ulong[]{0x304000UL});
		public static readonly BitSet _integer_constant_in_value_assignment251 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_last_enum_entry261 = new BitSet(new ulong[]{0x40802UL});
		public static readonly BitSet _value_assignment_in_last_enum_entry264 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _enum_conversion_tag_in_last_enum_entry267 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_non_last_enum_entry278 = new BitSet(new ulong[]{0x820UL});
		public static readonly BitSet _value_assignment_in_non_last_enum_entry281 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_non_last_enum_entry284 = new BitSet(new ulong[]{0x40002UL});
		public static readonly BitSet _enum_conversion_tag_in_non_last_enum_entry287 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_enum_entry_list299 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _non_last_enum_entry_in_enum_entry_list302 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _last_enum_entry_in_enum_entry_list305 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _RBRACE_in_enum_entry_list308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_extends_clause319 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_extends_clause322 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BITFIELD_in_enum_properties333 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _extends_clause_in_enum_properties337 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_begin_meta348 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ENUM_BEGIN_in_enum_begin_meta351 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _LPAREN_in_enum_begin_meta354 = new BitSet(new ulong[]{0x1001010UL});
		public static readonly BitSet _enum_properties_in_enum_begin_meta357 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _RPAREN_in_enum_begin_meta360 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_end_meta372 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ENUM_END_in_enum_end_meta375 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ENUM_in_enum_definition386 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_enum_definition389 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _enum_entry_list_in_enum_definition391 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _SEMICOLON_in_enum_definition393 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAMESPACE_in_namespace_wrapper405 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_namespace_wrapper408 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _LBRACE_in_namespace_wrapper410 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _enum_definition_in_namespace_wrapper413 = new BitSet(new ulong[]{0x800000UL});
		public static readonly BitSet _RBRACE_in_namespace_wrapper415 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namespace_wrapper_in_enum_entry_point427 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enum_definition_in_enum_entry_point431 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enum_begin_meta_in_parse446 = new BitSet(new ulong[]{0x80080UL});
		public static readonly BitSet _enum_entry_point_in_parse448 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _enum_end_meta_in_parse450 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
