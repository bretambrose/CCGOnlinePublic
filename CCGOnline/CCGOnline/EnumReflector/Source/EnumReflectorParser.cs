//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 3.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// $ANTLR 3.4 C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g 2012-12-08 12:46:11

// The variable 'variable' is assigned but its value is never used.
#pragma warning disable 219
// Unreachable code detected.
#pragma warning disable 162
// Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// CLS compliance checking will not be performed on 'type' because it is not visible from outside this assembly.
#pragma warning disable 3019


using System.Collections.Generic;
using Antlr.Runtime;
using Antlr.Runtime.Misc;


using Antlr.Runtime.Tree;
using RewriteRuleITokenStream = Antlr.Runtime.Tree.RewriteRuleTokenStream;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "3.4")]
public partial class EnumReflectorParser : Antlr.Runtime.Parser
{
	internal static readonly string[] tokenNames = new string[] {
		"<invalid>", "<EOR>", "<DOWN>", "<UP>", "BITFIELD", "COMMA", "DIGIT", "ENUM", "ENUM_BEGIN", "ENUM_END", "ENUM_ENTRY", "EQUALS", "EXTENDS", "HEX_DIGIT", "ID", "IDQUALIFIER", "LBRACE", "LEFT_SHIFT", "LPAREN", "META", "NAMESPACE", "POSITIVE_INTEGER10", "POSITIVE_INTEGER16", "POS_DIGIT", "RBRACE", "RPAREN", "SEMICOLON", "STRING", "WHITESPACE"
	};
	public const int EOF=-1;
	public const int BITFIELD=4;
	public const int COMMA=5;
	public const int DIGIT=6;
	public const int ENUM=7;
	public const int ENUM_BEGIN=8;
	public const int ENUM_END=9;
	public const int ENUM_ENTRY=10;
	public const int EQUALS=11;
	public const int EXTENDS=12;
	public const int HEX_DIGIT=13;
	public const int ID=14;
	public const int IDQUALIFIER=15;
	public const int LBRACE=16;
	public const int LEFT_SHIFT=17;
	public const int LPAREN=18;
	public const int META=19;
	public const int NAMESPACE=20;
	public const int POSITIVE_INTEGER10=21;
	public const int POSITIVE_INTEGER16=22;
	public const int POS_DIGIT=23;
	public const int RBRACE=24;
	public const int RPAREN=25;
	public const int SEMICOLON=26;
	public const int STRING=27;
	public const int WHITESPACE=28;

	public EnumReflectorParser(ITokenStream input)
		: this(input, new RecognizerSharedState())
	{
	}
	public EnumReflectorParser(ITokenStream input, RecognizerSharedState state)
		: base(input, state)
	{
		ITreeAdaptor treeAdaptor = default(ITreeAdaptor);
		CreateTreeAdaptor(ref treeAdaptor);
		TreeAdaptor = treeAdaptor ?? new CommonTreeAdaptor();
		OnCreated();
	}
	// Implement this function in your helper file to use a custom tree adaptor
	partial void CreateTreeAdaptor(ref ITreeAdaptor adaptor);

	private ITreeAdaptor adaptor;

	public ITreeAdaptor TreeAdaptor
	{
		get
		{
			return adaptor;
		}

		set
		{
			this.adaptor = value;
		}
	}

	public override string[] TokenNames { get { return EnumReflectorParser.tokenNames; } }
	public override string GrammarFileName { get { return "C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g"; } }


	partial void OnCreated();
	partial void EnterRule(string ruleName, int ruleIndex);
	partial void LeaveRule(string ruleName, int ruleIndex);

	#region Rules
	partial void EnterRule_qualifier_list();
	partial void LeaveRule_qualifier_list();

	// $ANTLR start "qualifier_list"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:32:1: qualifier_list : ( IDQUALIFIER ID )* ;
	[GrammarRule("qualifier_list")]
	private AstParserRuleReturnScope<object, IToken> qualifier_list()
	{
		EnterRule_qualifier_list();
		EnterRule("qualifier_list", 1);
		TraceIn("qualifier_list", 1);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken IDQUALIFIER1 = default(IToken);
		IToken ID2 = default(IToken);

		object IDQUALIFIER1_tree = default(object);
		object ID2_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "qualifier_list");
		DebugLocation(32, 23);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:2: ( ( IDQUALIFIER ID )* )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:4: ( IDQUALIFIER ID )*
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(33, 4);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:4: ( IDQUALIFIER ID )*
			try { DebugEnterSubRule(1);
			while (true)
			{
				int alt1=2;
				try { DebugEnterDecision(1, false);
				int LA1_0 = input.LA(1);

				if ((LA1_0==IDQUALIFIER))
				{
					alt1 = 1;
				}


				} finally { DebugExitDecision(1); }
				switch ( alt1 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:33:6: IDQUALIFIER ID
					{
					DebugLocation(33, 6);
					IDQUALIFIER1=(IToken)Match(input,IDQUALIFIER,Follow._IDQUALIFIER_in_qualifier_list197); 
					IDQUALIFIER1_tree = (object)adaptor.Create(IDQUALIFIER1);
					adaptor.AddChild(root_0, IDQUALIFIER1_tree);
					DebugLocation(33, 18);
					ID2=(IToken)Match(input,ID,Follow._ID_in_qualifier_list199); 
					ID2_tree = (object)adaptor.Create(ID2);
					adaptor.AddChild(root_0, ID2_tree);

					}
					break;

				default:
					goto loop1;
				}
			}

			loop1:
				;

			} finally { DebugExitSubRule(1); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qualifier_list", 1);
			LeaveRule("qualifier_list", 1);
			LeaveRule_qualifier_list();
		}
		DebugLocation(33, 23);
		} finally { DebugExitRule(GrammarFileName, "qualifier_list"); }
		return retval;

	}
	// $ANTLR end "qualifier_list"

	partial void EnterRule_qualified_id();
	partial void LeaveRule_qualified_id();

	// $ANTLR start "qualified_id"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:35:1: qualified_id : ID ^ qualifier_list ;
	[GrammarRule("qualified_id")]
	private AstParserRuleReturnScope<object, IToken> qualified_id()
	{
		EnterRule_qualified_id();
		EnterRule("qualified_id", 2);
		TraceIn("qualified_id", 2);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID3 = default(IToken);
		AstParserRuleReturnScope<object, IToken> qualifier_list4 = default(AstParserRuleReturnScope<object, IToken>);

		object ID3_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "qualified_id");
		DebugLocation(35, 22);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:2: ( ID ^ qualifier_list )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:36:4: ID ^ qualifier_list
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(36, 6);
			ID3=(IToken)Match(input,ID,Follow._ID_in_qualified_id213); 
			ID3_tree = (object)adaptor.Create(ID3);
			root_0 = (object)adaptor.BecomeRoot(ID3_tree, root_0);
			DebugLocation(36, 8);
			PushFollow(Follow._qualifier_list_in_qualified_id216);
			qualifier_list4=qualifier_list();
			PopFollow();

			adaptor.AddChild(root_0, qualifier_list4.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("qualified_id", 2);
			LeaveRule("qualified_id", 2);
			LeaveRule_qualified_id();
		}
		DebugLocation(36, 22);
		} finally { DebugExitRule(GrammarFileName, "qualified_id"); }
		return retval;

	}
	// $ANTLR end "qualified_id"

	partial void EnterRule_enum_conversion_tag();
	partial void LeaveRule_enum_conversion_tag();

	// $ANTLR start "enum_conversion_tag"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:38:1: enum_conversion_tag : META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !;
	[GrammarRule("enum_conversion_tag")]
	private AstParserRuleReturnScope<object, IToken> enum_conversion_tag()
	{
		EnterRule_enum_conversion_tag();
		EnterRule("enum_conversion_tag", 3);
		TraceIn("enum_conversion_tag", 3);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META5 = default(IToken);
		IToken ENUM_ENTRY6 = default(IToken);
		IToken LPAREN7 = default(IToken);
		IToken STRING8 = default(IToken);
		IToken RPAREN9 = default(IToken);

		object META5_tree = default(object);
		object ENUM_ENTRY6_tree = default(object);
		object LPAREN7_tree = default(object);
		object STRING8_tree = default(object);
		object RPAREN9_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_conversion_tag");
		DebugLocation(38, 44);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:39:2: ( META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:39:4: META ! ENUM_ENTRY ^ LPAREN ! STRING RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(39, 8);
			META5=(IToken)Match(input,META,Follow._META_in_enum_conversion_tag228); 
			DebugLocation(39, 20);
			ENUM_ENTRY6=(IToken)Match(input,ENUM_ENTRY,Follow._ENUM_ENTRY_in_enum_conversion_tag231); 
			ENUM_ENTRY6_tree = (object)adaptor.Create(ENUM_ENTRY6);
			root_0 = (object)adaptor.BecomeRoot(ENUM_ENTRY6_tree, root_0);
			DebugLocation(39, 28);
			LPAREN7=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_conversion_tag234); 
			DebugLocation(39, 30);
			STRING8=(IToken)Match(input,STRING,Follow._STRING_in_enum_conversion_tag237); 
			STRING8_tree = (object)adaptor.Create(STRING8);
			adaptor.AddChild(root_0, STRING8_tree);
			DebugLocation(39, 43);
			RPAREN9=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_conversion_tag239); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_conversion_tag", 3);
			LeaveRule("enum_conversion_tag", 3);
			LeaveRule_enum_conversion_tag();
		}
		DebugLocation(39, 44);
		} finally { DebugExitRule(GrammarFileName, "enum_conversion_tag"); }
		return retval;

	}
	// $ANTLR end "enum_conversion_tag"

	partial void EnterRule_shift_expression();
	partial void LeaveRule_shift_expression();

	// $ANTLR start "shift_expression"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:41:1: shift_expression : POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 ;
	[GrammarRule("shift_expression")]
	private AstParserRuleReturnScope<object, IToken> shift_expression()
	{
		EnterRule_shift_expression();
		EnterRule("shift_expression", 4);
		TraceIn("shift_expression", 4);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken POSITIVE_INTEGER1010 = default(IToken);
		IToken LEFT_SHIFT11 = default(IToken);
		IToken POSITIVE_INTEGER1012 = default(IToken);

		object POSITIVE_INTEGER1010_tree = default(object);
		object LEFT_SHIFT11_tree = default(object);
		object POSITIVE_INTEGER1012_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "shift_expression");
		DebugLocation(41, 53);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:2: ( POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10 )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:42:4: POSITIVE_INTEGER10 LEFT_SHIFT ^ POSITIVE_INTEGER10
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(42, 4);
			POSITIVE_INTEGER1010=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression250); 
			POSITIVE_INTEGER1010_tree = (object)adaptor.Create(POSITIVE_INTEGER1010);
			adaptor.AddChild(root_0, POSITIVE_INTEGER1010_tree);
			DebugLocation(42, 33);
			LEFT_SHIFT11=(IToken)Match(input,LEFT_SHIFT,Follow._LEFT_SHIFT_in_shift_expression252); 
			LEFT_SHIFT11_tree = (object)adaptor.Create(LEFT_SHIFT11);
			root_0 = (object)adaptor.BecomeRoot(LEFT_SHIFT11_tree, root_0);
			DebugLocation(42, 35);
			POSITIVE_INTEGER1012=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_shift_expression255); 
			POSITIVE_INTEGER1012_tree = (object)adaptor.Create(POSITIVE_INTEGER1012);
			adaptor.AddChild(root_0, POSITIVE_INTEGER1012_tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("shift_expression", 4);
			LeaveRule("shift_expression", 4);
			LeaveRule_shift_expression();
		}
		DebugLocation(42, 53);
		} finally { DebugExitRule(GrammarFileName, "shift_expression"); }
		return retval;

	}
	// $ANTLR end "shift_expression"

	partial void EnterRule_integer_constant();
	partial void LeaveRule_integer_constant();

	// $ANTLR start "integer_constant"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:44:1: integer_constant : ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 | qualified_id );
	[GrammarRule("integer_constant")]
	private AstParserRuleReturnScope<object, IToken> integer_constant()
	{
		EnterRule_integer_constant();
		EnterRule("integer_constant", 5);
		TraceIn("integer_constant", 5);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken POSITIVE_INTEGER1614 = default(IToken);
		IToken POSITIVE_INTEGER1015 = default(IToken);
		AstParserRuleReturnScope<object, IToken> shift_expression13 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> qualified_id16 = default(AstParserRuleReturnScope<object, IToken>);

		object POSITIVE_INTEGER1614_tree = default(object);
		object POSITIVE_INTEGER1015_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "integer_constant");
		DebugLocation(44, 76);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:2: ( shift_expression | POSITIVE_INTEGER16 | POSITIVE_INTEGER10 | qualified_id )
			int alt2=4;
			try { DebugEnterDecision(2, false);
			switch (input.LA(1))
			{
			case POSITIVE_INTEGER10:
				{
				int LA2_1 = input.LA(2);

				if ((LA2_1==LEFT_SHIFT))
				{
					alt2 = 1;
				}
				else if ((LA2_1==COMMA||LA2_1==META||LA2_1==RBRACE))
				{
					alt2 = 3;
				}
				else
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 1, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
				}
				break;
			case POSITIVE_INTEGER16:
				{
				alt2 = 2;
				}
				break;
			case ID:
				{
				alt2 = 4;
				}
				break;
			default:
				{
					NoViableAltException nvae = new NoViableAltException("", 2, 0, input);
					DebugRecognitionException(nvae);
					throw nvae;
				}
			}

			} finally { DebugExitDecision(2); }
			switch (alt2)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:4: shift_expression
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(45, 4);
				PushFollow(Follow._shift_expression_in_integer_constant268);
				shift_expression13=shift_expression();
				PopFollow();

				adaptor.AddChild(root_0, shift_expression13.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:23: POSITIVE_INTEGER16
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(45, 23);
				POSITIVE_INTEGER1614=(IToken)Match(input,POSITIVE_INTEGER16,Follow._POSITIVE_INTEGER16_in_integer_constant272); 
				POSITIVE_INTEGER1614_tree = (object)adaptor.Create(POSITIVE_INTEGER1614);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1614_tree);

				}
				break;
			case 3:
				DebugEnterAlt(3);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:44: POSITIVE_INTEGER10
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(45, 44);
				POSITIVE_INTEGER1015=(IToken)Match(input,POSITIVE_INTEGER10,Follow._POSITIVE_INTEGER10_in_integer_constant276); 
				POSITIVE_INTEGER1015_tree = (object)adaptor.Create(POSITIVE_INTEGER1015);
				adaptor.AddChild(root_0, POSITIVE_INTEGER1015_tree);

				}
				break;
			case 4:
				DebugEnterAlt(4);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:45:65: qualified_id
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(45, 65);
				PushFollow(Follow._qualified_id_in_integer_constant280);
				qualified_id16=qualified_id();
				PopFollow();

				adaptor.AddChild(root_0, qualified_id16.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("integer_constant", 5);
			LeaveRule("integer_constant", 5);
			LeaveRule_integer_constant();
		}
		DebugLocation(45, 76);
		} finally { DebugExitRule(GrammarFileName, "integer_constant"); }
		return retval;

	}
	// $ANTLR end "integer_constant"

	partial void EnterRule_value_assignment();
	partial void LeaveRule_value_assignment();

	// $ANTLR start "value_assignment"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:47:1: value_assignment : EQUALS ! integer_constant ;
	[GrammarRule("value_assignment")]
	private AstParserRuleReturnScope<object, IToken> value_assignment()
	{
		EnterRule_value_assignment();
		EnterRule("value_assignment", 6);
		TraceIn("value_assignment", 6);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EQUALS17 = default(IToken);
		AstParserRuleReturnScope<object, IToken> integer_constant18 = default(AstParserRuleReturnScope<object, IToken>);

		object EQUALS17_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "value_assignment");
		DebugLocation(47, 28);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:2: ( EQUALS ! integer_constant )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:48:4: EQUALS ! integer_constant
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(48, 10);
			EQUALS17=(IToken)Match(input,EQUALS,Follow._EQUALS_in_value_assignment289); 
			DebugLocation(48, 12);
			PushFollow(Follow._integer_constant_in_value_assignment292);
			integer_constant18=integer_constant();
			PopFollow();

			adaptor.AddChild(root_0, integer_constant18.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("value_assignment", 6);
			LeaveRule("value_assignment", 6);
			LeaveRule_value_assignment();
		}
		DebugLocation(48, 28);
		} finally { DebugExitRule(GrammarFileName, "value_assignment"); }
		return retval;

	}
	// $ANTLR end "value_assignment"

	partial void EnterRule_last_enum_entry();
	partial void LeaveRule_last_enum_entry();

	// $ANTLR start "last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:50:1: last_enum_entry : ID ^ ( value_assignment )? ( enum_conversion_tag )? ;
	[GrammarRule("last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> last_enum_entry()
	{
		EnterRule_last_enum_entry();
		EnterRule("last_enum_entry", 7);
		TraceIn("last_enum_entry", 7);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID19 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_assignment20 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_conversion_tag21 = default(AstParserRuleReturnScope<object, IToken>);

		object ID19_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "last_enum_entry");
		DebugLocation(50, 46);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:2: ( ID ^ ( value_assignment )? ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:4: ID ^ ( value_assignment )? ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(51, 6);
			ID19=(IToken)Match(input,ID,Follow._ID_in_last_enum_entry302); 
			ID19_tree = (object)adaptor.Create(ID19);
			root_0 = (object)adaptor.BecomeRoot(ID19_tree, root_0);
			DebugLocation(51, 8);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:8: ( value_assignment )?
			int alt3=2;
			try { DebugEnterSubRule(3);
			try { DebugEnterDecision(3, false);
			int LA3_0 = input.LA(1);

			if ((LA3_0==EQUALS))
			{
				alt3 = 1;
			}
			} finally { DebugExitDecision(3); }
			switch (alt3)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:8: value_assignment
				{
				DebugLocation(51, 8);
				PushFollow(Follow._value_assignment_in_last_enum_entry305);
				value_assignment20=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment20.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(3); }

			DebugLocation(51, 26);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:26: ( enum_conversion_tag )?
			int alt4=2;
			try { DebugEnterSubRule(4);
			try { DebugEnterDecision(4, false);
			int LA4_0 = input.LA(1);

			if ((LA4_0==META))
			{
				alt4 = 1;
			}
			} finally { DebugExitDecision(4); }
			switch (alt4)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:51:26: enum_conversion_tag
				{
				DebugLocation(51, 26);
				PushFollow(Follow._enum_conversion_tag_in_last_enum_entry308);
				enum_conversion_tag21=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag21.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(4); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("last_enum_entry", 7);
			LeaveRule("last_enum_entry", 7);
			LeaveRule_last_enum_entry();
		}
		DebugLocation(51, 46);
		} finally { DebugExitRule(GrammarFileName, "last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "last_enum_entry"

	partial void EnterRule_non_last_enum_entry();
	partial void LeaveRule_non_last_enum_entry();

	// $ANTLR start "non_last_enum_entry"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:53:1: non_last_enum_entry : ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )? ;
	[GrammarRule("non_last_enum_entry")]
	private AstParserRuleReturnScope<object, IToken> non_last_enum_entry()
	{
		EnterRule_non_last_enum_entry();
		EnterRule("non_last_enum_entry", 8);
		TraceIn("non_last_enum_entry", 8);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ID22 = default(IToken);
		IToken COMMA24 = default(IToken);
		AstParserRuleReturnScope<object, IToken> value_assignment23 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_conversion_tag25 = default(AstParserRuleReturnScope<object, IToken>);

		object ID22_tree = default(object);
		object COMMA24_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "non_last_enum_entry");
		DebugLocation(53, 53);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:2: ( ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )? )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:4: ID ^ ( value_assignment )? COMMA ! ( enum_conversion_tag )?
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(54, 6);
			ID22=(IToken)Match(input,ID,Follow._ID_in_non_last_enum_entry319); 
			ID22_tree = (object)adaptor.Create(ID22);
			root_0 = (object)adaptor.BecomeRoot(ID22_tree, root_0);
			DebugLocation(54, 8);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:8: ( value_assignment )?
			int alt5=2;
			try { DebugEnterSubRule(5);
			try { DebugEnterDecision(5, false);
			int LA5_0 = input.LA(1);

			if ((LA5_0==EQUALS))
			{
				alt5 = 1;
			}
			} finally { DebugExitDecision(5); }
			switch (alt5)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:8: value_assignment
				{
				DebugLocation(54, 8);
				PushFollow(Follow._value_assignment_in_non_last_enum_entry322);
				value_assignment23=value_assignment();
				PopFollow();

				adaptor.AddChild(root_0, value_assignment23.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(5); }

			DebugLocation(54, 31);
			COMMA24=(IToken)Match(input,COMMA,Follow._COMMA_in_non_last_enum_entry325); 
			DebugLocation(54, 33);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:33: ( enum_conversion_tag )?
			int alt6=2;
			try { DebugEnterSubRule(6);
			try { DebugEnterDecision(6, false);
			int LA6_0 = input.LA(1);

			if ((LA6_0==META))
			{
				alt6 = 1;
			}
			} finally { DebugExitDecision(6); }
			switch (alt6)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:54:33: enum_conversion_tag
				{
				DebugLocation(54, 33);
				PushFollow(Follow._enum_conversion_tag_in_non_last_enum_entry328);
				enum_conversion_tag25=enum_conversion_tag();
				PopFollow();

				adaptor.AddChild(root_0, enum_conversion_tag25.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(6); }


			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("non_last_enum_entry", 8);
			LeaveRule("non_last_enum_entry", 8);
			LeaveRule_non_last_enum_entry();
		}
		DebugLocation(54, 53);
		} finally { DebugExitRule(GrammarFileName, "non_last_enum_entry"); }
		return retval;

	}
	// $ANTLR end "non_last_enum_entry"

	partial void EnterRule_enum_entry_list();
	partial void LeaveRule_enum_entry_list();

	// $ANTLR start "enum_entry_list"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:56:1: enum_entry_list : LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !;
	[GrammarRule("enum_entry_list")]
	private AstParserRuleReturnScope<object, IToken> enum_entry_list()
	{
		EnterRule_enum_entry_list();
		EnterRule("enum_entry_list", 9);
		TraceIn("enum_entry_list", 9);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken LBRACE26 = default(IToken);
		IToken RBRACE29 = default(IToken);
		AstParserRuleReturnScope<object, IToken> non_last_enum_entry27 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> last_enum_entry28 = default(AstParserRuleReturnScope<object, IToken>);

		object LBRACE26_tree = default(object);
		object RBRACE29_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_entry_list");
		DebugLocation(56, 57);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:2: ( LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:4: LBRACE ^ ( non_last_enum_entry )* last_enum_entry RBRACE !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(57, 10);
			LBRACE26=(IToken)Match(input,LBRACE,Follow._LBRACE_in_enum_entry_list340); 
			LBRACE26_tree = (object)adaptor.Create(LBRACE26);
			root_0 = (object)adaptor.BecomeRoot(LBRACE26_tree, root_0);
			DebugLocation(57, 12);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:12: ( non_last_enum_entry )*
			try { DebugEnterSubRule(7);
			while (true)
			{
				int alt7=2;
				try { DebugEnterDecision(7, false);
				try
				{
					alt7 = dfa7.Predict(input);
				}
				catch (NoViableAltException nvae)
				{
					DebugRecognitionException(nvae);
					throw;
				}
				} finally { DebugExitDecision(7); }
				switch ( alt7 )
				{
				case 1:
					DebugEnterAlt(1);
					// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:57:12: non_last_enum_entry
					{
					DebugLocation(57, 12);
					PushFollow(Follow._non_last_enum_entry_in_enum_entry_list343);
					non_last_enum_entry27=non_last_enum_entry();
					PopFollow();

					adaptor.AddChild(root_0, non_last_enum_entry27.Tree);

					}
					break;

				default:
					goto loop7;
				}
			}

			loop7:
				;

			} finally { DebugExitSubRule(7); }

			DebugLocation(57, 33);
			PushFollow(Follow._last_enum_entry_in_enum_entry_list346);
			last_enum_entry28=last_enum_entry();
			PopFollow();

			adaptor.AddChild(root_0, last_enum_entry28.Tree);
			DebugLocation(57, 56);
			RBRACE29=(IToken)Match(input,RBRACE,Follow._RBRACE_in_enum_entry_list349); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_entry_list", 9);
			LeaveRule("enum_entry_list", 9);
			LeaveRule_enum_entry_list();
		}
		DebugLocation(57, 57);
		} finally { DebugExitRule(GrammarFileName, "enum_entry_list"); }
		return retval;

	}
	// $ANTLR end "enum_entry_list"

	partial void EnterRule_extends_clause();
	partial void LeaveRule_extends_clause();

	// $ANTLR start "extends_clause"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:59:1: extends_clause : EXTENDS ^ qualified_id ;
	[GrammarRule("extends_clause")]
	private AstParserRuleReturnScope<object, IToken> extends_clause()
	{
		EnterRule_extends_clause();
		EnterRule("extends_clause", 10);
		TraceIn("extends_clause", 10);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken EXTENDS30 = default(IToken);
		AstParserRuleReturnScope<object, IToken> qualified_id31 = default(AstParserRuleReturnScope<object, IToken>);

		object EXTENDS30_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "extends_clause");
		DebugLocation(59, 25);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:60:2: ( EXTENDS ^ qualified_id )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:60:4: EXTENDS ^ qualified_id
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(60, 11);
			EXTENDS30=(IToken)Match(input,EXTENDS,Follow._EXTENDS_in_extends_clause360); 
			EXTENDS30_tree = (object)adaptor.Create(EXTENDS30);
			root_0 = (object)adaptor.BecomeRoot(EXTENDS30_tree, root_0);
			DebugLocation(60, 13);
			PushFollow(Follow._qualified_id_in_extends_clause363);
			qualified_id31=qualified_id();
			PopFollow();

			adaptor.AddChild(root_0, qualified_id31.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("extends_clause", 10);
			LeaveRule("extends_clause", 10);
			LeaveRule_extends_clause();
		}
		DebugLocation(60, 25);
		} finally { DebugExitRule(GrammarFileName, "extends_clause"); }
		return retval;

	}
	// $ANTLR end "extends_clause"

	partial void EnterRule_enum_properties();
	partial void LeaveRule_enum_properties();

	// $ANTLR start "enum_properties"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:62:1: enum_properties : ( BITFIELD | extends_clause );
	[GrammarRule("enum_properties")]
	private AstParserRuleReturnScope<object, IToken> enum_properties()
	{
		EnterRule_enum_properties();
		EnterRule("enum_properties", 11);
		TraceIn("enum_properties", 11);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken BITFIELD32 = default(IToken);
		AstParserRuleReturnScope<object, IToken> extends_clause33 = default(AstParserRuleReturnScope<object, IToken>);

		object BITFIELD32_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_properties");
		DebugLocation(62, 29);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:63:2: ( BITFIELD | extends_clause )
			int alt8=2;
			try { DebugEnterDecision(8, false);
			int LA8_0 = input.LA(1);

			if ((LA8_0==BITFIELD))
			{
				alt8 = 1;
			}
			else if ((LA8_0==EXTENDS))
			{
				alt8 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 8, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(8); }
			switch (alt8)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:63:4: BITFIELD
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(63, 4);
				BITFIELD32=(IToken)Match(input,BITFIELD,Follow._BITFIELD_in_enum_properties374); 
				BITFIELD32_tree = (object)adaptor.Create(BITFIELD32);
				adaptor.AddChild(root_0, BITFIELD32_tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:63:15: extends_clause
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(63, 15);
				PushFollow(Follow._extends_clause_in_enum_properties378);
				extends_clause33=extends_clause();
				PopFollow();

				adaptor.AddChild(root_0, extends_clause33.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_properties", 11);
			LeaveRule("enum_properties", 11);
			LeaveRule_enum_properties();
		}
		DebugLocation(63, 29);
		} finally { DebugExitRule(GrammarFileName, "enum_properties"); }
		return retval;

	}
	// $ANTLR end "enum_properties"

	partial void EnterRule_enum_begin_meta();
	partial void LeaveRule_enum_begin_meta();

	// $ANTLR start "enum_begin_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:65:1: enum_begin_meta : META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !;
	[GrammarRule("enum_begin_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_begin_meta()
	{
		EnterRule_enum_begin_meta();
		EnterRule("enum_begin_meta", 12);
		TraceIn("enum_begin_meta", 12);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META34 = default(IToken);
		IToken ENUM_BEGIN35 = default(IToken);
		IToken LPAREN36 = default(IToken);
		IToken RPAREN38 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enum_properties37 = default(AstParserRuleReturnScope<object, IToken>);

		object META34_tree = default(object);
		object ENUM_BEGIN35_tree = default(object);
		object LPAREN36_tree = default(object);
		object RPAREN38_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_begin_meta");
		DebugLocation(65, 54);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:66:2: ( META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:66:4: META ! ENUM_BEGIN ^ LPAREN ! ( enum_properties )? RPAREN !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(66, 8);
			META34=(IToken)Match(input,META,Follow._META_in_enum_begin_meta389); 
			DebugLocation(66, 20);
			ENUM_BEGIN35=(IToken)Match(input,ENUM_BEGIN,Follow._ENUM_BEGIN_in_enum_begin_meta392); 
			ENUM_BEGIN35_tree = (object)adaptor.Create(ENUM_BEGIN35);
			root_0 = (object)adaptor.BecomeRoot(ENUM_BEGIN35_tree, root_0);
			DebugLocation(66, 28);
			LPAREN36=(IToken)Match(input,LPAREN,Follow._LPAREN_in_enum_begin_meta395); 
			DebugLocation(66, 30);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:66:30: ( enum_properties )?
			int alt9=2;
			try { DebugEnterSubRule(9);
			try { DebugEnterDecision(9, false);
			int LA9_0 = input.LA(1);

			if ((LA9_0==BITFIELD||LA9_0==EXTENDS))
			{
				alt9 = 1;
			}
			} finally { DebugExitDecision(9); }
			switch (alt9)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:66:30: enum_properties
				{
				DebugLocation(66, 30);
				PushFollow(Follow._enum_properties_in_enum_begin_meta398);
				enum_properties37=enum_properties();
				PopFollow();

				adaptor.AddChild(root_0, enum_properties37.Tree);

				}
				break;

			}
			} finally { DebugExitSubRule(9); }

			DebugLocation(66, 53);
			RPAREN38=(IToken)Match(input,RPAREN,Follow._RPAREN_in_enum_begin_meta401); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_begin_meta", 12);
			LeaveRule("enum_begin_meta", 12);
			LeaveRule_enum_begin_meta();
		}
		DebugLocation(66, 54);
		} finally { DebugExitRule(GrammarFileName, "enum_begin_meta"); }
		return retval;

	}
	// $ANTLR end "enum_begin_meta"

	partial void EnterRule_enum_end_meta();
	partial void LeaveRule_enum_end_meta();

	// $ANTLR start "enum_end_meta"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:68:1: enum_end_meta : META ! ENUM_END ^;
	[GrammarRule("enum_end_meta")]
	private AstParserRuleReturnScope<object, IToken> enum_end_meta()
	{
		EnterRule_enum_end_meta();
		EnterRule("enum_end_meta", 13);
		TraceIn("enum_end_meta", 13);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken META39 = default(IToken);
		IToken ENUM_END40 = default(IToken);

		object META39_tree = default(object);
		object ENUM_END40_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_end_meta");
		DebugLocation(68, 19);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:69:2: ( META ! ENUM_END ^)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:69:4: META ! ENUM_END ^
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(69, 8);
			META39=(IToken)Match(input,META,Follow._META_in_enum_end_meta413); 
			DebugLocation(69, 18);
			ENUM_END40=(IToken)Match(input,ENUM_END,Follow._ENUM_END_in_enum_end_meta416); 
			ENUM_END40_tree = (object)adaptor.Create(ENUM_END40);
			root_0 = (object)adaptor.BecomeRoot(ENUM_END40_tree, root_0);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_end_meta", 13);
			LeaveRule("enum_end_meta", 13);
			LeaveRule_enum_end_meta();
		}
		DebugLocation(69, 19);
		} finally { DebugExitRule(GrammarFileName, "enum_end_meta"); }
		return retval;

	}
	// $ANTLR end "enum_end_meta"

	partial void EnterRule_enum_definition();
	partial void LeaveRule_enum_definition();

	// $ANTLR start "enum_definition"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:71:1: enum_definition : ENUM ^ ID enum_entry_list SEMICOLON !;
	[GrammarRule("enum_definition")]
	private AstParserRuleReturnScope<object, IToken> enum_definition()
	{
		EnterRule_enum_definition();
		EnterRule("enum_definition", 14);
		TraceIn("enum_definition", 14);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken ENUM41 = default(IToken);
		IToken ID42 = default(IToken);
		IToken SEMICOLON44 = default(IToken);
		AstParserRuleReturnScope<object, IToken> enum_entry_list43 = default(AstParserRuleReturnScope<object, IToken>);

		object ENUM41_tree = default(object);
		object ID42_tree = default(object);
		object SEMICOLON44_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "enum_definition");
		DebugLocation(71, 39);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:72:2: ( ENUM ^ ID enum_entry_list SEMICOLON !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:72:4: ENUM ^ ID enum_entry_list SEMICOLON !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(72, 8);
			ENUM41=(IToken)Match(input,ENUM,Follow._ENUM_in_enum_definition427); 
			ENUM41_tree = (object)adaptor.Create(ENUM41);
			root_0 = (object)adaptor.BecomeRoot(ENUM41_tree, root_0);
			DebugLocation(72, 10);
			ID42=(IToken)Match(input,ID,Follow._ID_in_enum_definition430); 
			ID42_tree = (object)adaptor.Create(ID42);
			adaptor.AddChild(root_0, ID42_tree);
			DebugLocation(72, 13);
			PushFollow(Follow._enum_entry_list_in_enum_definition432);
			enum_entry_list43=enum_entry_list();
			PopFollow();

			adaptor.AddChild(root_0, enum_entry_list43.Tree);
			DebugLocation(72, 38);
			SEMICOLON44=(IToken)Match(input,SEMICOLON,Follow._SEMICOLON_in_enum_definition434); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_definition", 14);
			LeaveRule("enum_definition", 14);
			LeaveRule_enum_definition();
		}
		DebugLocation(72, 39);
		} finally { DebugExitRule(GrammarFileName, "enum_definition"); }
		return retval;

	}
	// $ANTLR end "enum_definition"

	partial void EnterRule_namespace_wrapper();
	partial void LeaveRule_namespace_wrapper();

	// $ANTLR start "namespace_wrapper"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:74:1: namespace_wrapper : NAMESPACE ^ qualified_id LBRACE ! enum_definition RBRACE !;
	[GrammarRule("namespace_wrapper")]
	private AstParserRuleReturnScope<object, IToken> namespace_wrapper()
	{
		EnterRule_namespace_wrapper();
		EnterRule("namespace_wrapper", 15);
		TraceIn("namespace_wrapper", 15);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		IToken NAMESPACE45 = default(IToken);
		IToken LBRACE47 = default(IToken);
		IToken RBRACE49 = default(IToken);
		AstParserRuleReturnScope<object, IToken> qualified_id46 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_definition48 = default(AstParserRuleReturnScope<object, IToken>);

		object NAMESPACE45_tree = default(object);
		object LBRACE47_tree = default(object);
		object RBRACE49_tree = default(object);
		try { DebugEnterRule(GrammarFileName, "namespace_wrapper");
		DebugLocation(74, 59);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:75:2: ( NAMESPACE ^ qualified_id LBRACE ! enum_definition RBRACE !)
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:75:4: NAMESPACE ^ qualified_id LBRACE ! enum_definition RBRACE !
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(75, 13);
			NAMESPACE45=(IToken)Match(input,NAMESPACE,Follow._NAMESPACE_in_namespace_wrapper446); 
			NAMESPACE45_tree = (object)adaptor.Create(NAMESPACE45);
			root_0 = (object)adaptor.BecomeRoot(NAMESPACE45_tree, root_0);
			DebugLocation(75, 15);
			PushFollow(Follow._qualified_id_in_namespace_wrapper449);
			qualified_id46=qualified_id();
			PopFollow();

			adaptor.AddChild(root_0, qualified_id46.Tree);
			DebugLocation(75, 34);
			LBRACE47=(IToken)Match(input,LBRACE,Follow._LBRACE_in_namespace_wrapper451); 
			DebugLocation(75, 36);
			PushFollow(Follow._enum_definition_in_namespace_wrapper454);
			enum_definition48=enum_definition();
			PopFollow();

			adaptor.AddChild(root_0, enum_definition48.Tree);
			DebugLocation(75, 58);
			RBRACE49=(IToken)Match(input,RBRACE,Follow._RBRACE_in_namespace_wrapper456); 

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("namespace_wrapper", 15);
			LeaveRule("namespace_wrapper", 15);
			LeaveRule_namespace_wrapper();
		}
		DebugLocation(75, 59);
		} finally { DebugExitRule(GrammarFileName, "namespace_wrapper"); }
		return retval;

	}
	// $ANTLR end "namespace_wrapper"

	partial void EnterRule_enum_entry_point();
	partial void LeaveRule_enum_entry_point();

	// $ANTLR start "enum_entry_point"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:77:1: enum_entry_point : ( namespace_wrapper | enum_definition );
	[GrammarRule("enum_entry_point")]
	private AstParserRuleReturnScope<object, IToken> enum_entry_point()
	{
		EnterRule_enum_entry_point();
		EnterRule("enum_entry_point", 16);
		TraceIn("enum_entry_point", 16);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> namespace_wrapper50 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_definition51 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "enum_entry_point");
		DebugLocation(77, 39);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:78:2: ( namespace_wrapper | enum_definition )
			int alt10=2;
			try { DebugEnterDecision(10, false);
			int LA10_0 = input.LA(1);

			if ((LA10_0==NAMESPACE))
			{
				alt10 = 1;
			}
			else if ((LA10_0==ENUM))
			{
				alt10 = 2;
			}
			else
			{
				NoViableAltException nvae = new NoViableAltException("", 10, 0, input);
				DebugRecognitionException(nvae);
				throw nvae;
			}
			} finally { DebugExitDecision(10); }
			switch (alt10)
			{
			case 1:
				DebugEnterAlt(1);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:78:4: namespace_wrapper
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 4);
				PushFollow(Follow._namespace_wrapper_in_enum_entry_point468);
				namespace_wrapper50=namespace_wrapper();
				PopFollow();

				adaptor.AddChild(root_0, namespace_wrapper50.Tree);

				}
				break;
			case 2:
				DebugEnterAlt(2);
				// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:78:24: enum_definition
				{
				root_0 = (object)adaptor.Nil();

				DebugLocation(78, 24);
				PushFollow(Follow._enum_definition_in_enum_entry_point472);
				enum_definition51=enum_definition();
				PopFollow();

				adaptor.AddChild(root_0, enum_definition51.Tree);

				}
				break;

			}
			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("enum_entry_point", 16);
			LeaveRule("enum_entry_point", 16);
			LeaveRule_enum_entry_point();
		}
		DebugLocation(78, 39);
		} finally { DebugExitRule(GrammarFileName, "enum_entry_point"); }
		return retval;

	}
	// $ANTLR end "enum_entry_point"

	partial void EnterRule_parse();
	partial void LeaveRule_parse();

	// $ANTLR start "parse"
	// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:80:8: public parse : enum_begin_meta enum_entry_point enum_end_meta ;
	[GrammarRule("parse")]
	public AstParserRuleReturnScope<object, IToken> parse()
	{
		EnterRule_parse();
		EnterRule("parse", 17);
		TraceIn("parse", 17);
		AstParserRuleReturnScope<object, IToken> retval = new AstParserRuleReturnScope<object, IToken>();
		retval.Start = (IToken)input.LT(1);

		object root_0 = default(object);

		AstParserRuleReturnScope<object, IToken> enum_begin_meta52 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_entry_point53 = default(AstParserRuleReturnScope<object, IToken>);
		AstParserRuleReturnScope<object, IToken> enum_end_meta54 = default(AstParserRuleReturnScope<object, IToken>);

		try { DebugEnterRule(GrammarFileName, "parse");
		DebugLocation(80, 50);
		try
		{
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:81:2: ( enum_begin_meta enum_entry_point enum_end_meta )
			DebugEnterAlt(1);
			// C:\\GitProjects\\CCGOnlinePublic\\CCGOnline\\CCGOnline\\Grammars\\EnumReflector.g:81:4: enum_begin_meta enum_entry_point enum_end_meta
			{
			root_0 = (object)adaptor.Nil();

			DebugLocation(81, 4);
			PushFollow(Follow._enum_begin_meta_in_parse487);
			enum_begin_meta52=enum_begin_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_begin_meta52.Tree);
			DebugLocation(81, 20);
			PushFollow(Follow._enum_entry_point_in_parse489);
			enum_entry_point53=enum_entry_point();
			PopFollow();

			adaptor.AddChild(root_0, enum_entry_point53.Tree);
			DebugLocation(81, 37);
			PushFollow(Follow._enum_end_meta_in_parse491);
			enum_end_meta54=enum_end_meta();
			PopFollow();

			adaptor.AddChild(root_0, enum_end_meta54.Tree);

			}

			retval.Stop = (IToken)input.LT(-1);

			retval.Tree = (object)adaptor.RulePostProcessing(root_0);
			adaptor.SetTokenBoundaries(retval.Tree, retval.Start, retval.Stop);

		}
		catch (RecognitionException re)
		{
			ReportError(re);
			Recover(input,re);
		retval.Tree = (object)adaptor.ErrorNode(input, retval.Start, input.LT(-1), re);

		}
		finally
		{
			TraceOut("parse", 17);
			LeaveRule("parse", 17);
			LeaveRule_parse();
		}
		DebugLocation(81, 50);
		} finally { DebugExitRule(GrammarFileName, "parse"); }
		return retval;

	}
	// $ANTLR end "parse"
	#endregion Rules


	#region DFA
	private DFA7 dfa7;

	protected override void InitDFAs()
	{
		base.InitDFAs();
		dfa7 = new DFA7( this );
	}

	private class DFA7 : DFA
	{
		private const string DFA7_eotS =
			"\xC\xFFFF";
		private const string DFA7_eofS =
			"\xC\xFFFF";
		private const string DFA7_minS =
			"\x1\xE\x1\x5\x1\xE\x2\xFFFF\x3\x5\x1\x15\x1\xE\x2\x5";
		private const string DFA7_maxS =
			"\x1\xE\x1\x18\x1\x16\x2\xFFFF\x3\x18\x1\x15\x1\xE\x2\x18";
		private const string DFA7_acceptS =
			"\x3\xFFFF\x1\x2\x1\x1\x7\xFFFF";
		private const string DFA7_specialS =
			"\xC\xFFFF}>";
		private static readonly string[] DFA7_transitionS =
			{
				"\x1\x1",
				"\x1\x4\x5\xFFFF\x1\x2\x7\xFFFF\x1\x3\x4\xFFFF\x1\x3",
				"\x1\x7\x6\xFFFF\x1\x5\x1\x6",
				"",
				"",
				"\x1\x4\xB\xFFFF\x1\x8\x1\xFFFF\x1\x3\x4\xFFFF\x1\x3",
				"\x1\x4\xD\xFFFF\x1\x3\x4\xFFFF\x1\x3",
				"\x1\x4\x9\xFFFF\x1\x9\x3\xFFFF\x1\x3\x4\xFFFF\x1\x3",
				"\x1\xA",
				"\x1\xB",
				"\x1\x4\xD\xFFFF\x1\x3\x4\xFFFF\x1\x3",
				"\x1\x4\x9\xFFFF\x1\x9\x3\xFFFF\x1\x3\x4\xFFFF\x1\x3"
			};

		private static readonly short[] DFA7_eot = DFA.UnpackEncodedString(DFA7_eotS);
		private static readonly short[] DFA7_eof = DFA.UnpackEncodedString(DFA7_eofS);
		private static readonly char[] DFA7_min = DFA.UnpackEncodedStringToUnsignedChars(DFA7_minS);
		private static readonly char[] DFA7_max = DFA.UnpackEncodedStringToUnsignedChars(DFA7_maxS);
		private static readonly short[] DFA7_accept = DFA.UnpackEncodedString(DFA7_acceptS);
		private static readonly short[] DFA7_special = DFA.UnpackEncodedString(DFA7_specialS);
		private static readonly short[][] DFA7_transition;

		static DFA7()
		{
			int numStates = DFA7_transitionS.Length;
			DFA7_transition = new short[numStates][];
			for ( int i=0; i < numStates; i++ )
			{
				DFA7_transition[i] = DFA.UnpackEncodedString(DFA7_transitionS[i]);
			}
		}

		public DFA7( BaseRecognizer recognizer )
		{
			this.recognizer = recognizer;
			this.decisionNumber = 7;
			this.eot = DFA7_eot;
			this.eof = DFA7_eof;
			this.min = DFA7_min;
			this.max = DFA7_max;
			this.accept = DFA7_accept;
			this.special = DFA7_special;
			this.transition = DFA7_transition;
		}

		public override string Description { get { return "()* loopback of 57:12: ( non_last_enum_entry )*"; } }

		public override void Error(NoViableAltException nvae)
		{
			DebugRecognitionException(nvae);
		}
	}


	#endregion DFA

	#region Follow sets
	private static class Follow
	{
		public static readonly BitSet _IDQUALIFIER_in_qualifier_list197 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_qualifier_list199 = new BitSet(new ulong[]{0x8002UL});
		public static readonly BitSet _ID_in_qualified_id213 = new BitSet(new ulong[]{0x8000UL});
		public static readonly BitSet _qualifier_list_in_qualified_id216 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_conversion_tag228 = new BitSet(new ulong[]{0x400UL});
		public static readonly BitSet _ENUM_ENTRY_in_enum_conversion_tag231 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _LPAREN_in_enum_conversion_tag234 = new BitSet(new ulong[]{0x8000000UL});
		public static readonly BitSet _STRING_in_enum_conversion_tag237 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _RPAREN_in_enum_conversion_tag239 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression250 = new BitSet(new ulong[]{0x20000UL});
		public static readonly BitSet _LEFT_SHIFT_in_shift_expression252 = new BitSet(new ulong[]{0x200000UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_shift_expression255 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _shift_expression_in_integer_constant268 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER16_in_integer_constant272 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _POSITIVE_INTEGER10_in_integer_constant276 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _qualified_id_in_integer_constant280 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EQUALS_in_value_assignment289 = new BitSet(new ulong[]{0x604000UL});
		public static readonly BitSet _integer_constant_in_value_assignment292 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_last_enum_entry302 = new BitSet(new ulong[]{0x80802UL});
		public static readonly BitSet _value_assignment_in_last_enum_entry305 = new BitSet(new ulong[]{0x80002UL});
		public static readonly BitSet _enum_conversion_tag_in_last_enum_entry308 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ID_in_non_last_enum_entry319 = new BitSet(new ulong[]{0x820UL});
		public static readonly BitSet _value_assignment_in_non_last_enum_entry322 = new BitSet(new ulong[]{0x20UL});
		public static readonly BitSet _COMMA_in_non_last_enum_entry325 = new BitSet(new ulong[]{0x80002UL});
		public static readonly BitSet _enum_conversion_tag_in_non_last_enum_entry328 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _LBRACE_in_enum_entry_list340 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _non_last_enum_entry_in_enum_entry_list343 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _last_enum_entry_in_enum_entry_list346 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _RBRACE_in_enum_entry_list349 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _EXTENDS_in_extends_clause360 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _qualified_id_in_extends_clause363 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _BITFIELD_in_enum_properties374 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _extends_clause_in_enum_properties378 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_begin_meta389 = new BitSet(new ulong[]{0x100UL});
		public static readonly BitSet _ENUM_BEGIN_in_enum_begin_meta392 = new BitSet(new ulong[]{0x40000UL});
		public static readonly BitSet _LPAREN_in_enum_begin_meta395 = new BitSet(new ulong[]{0x2001010UL});
		public static readonly BitSet _enum_properties_in_enum_begin_meta398 = new BitSet(new ulong[]{0x2000000UL});
		public static readonly BitSet _RPAREN_in_enum_begin_meta401 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _META_in_enum_end_meta413 = new BitSet(new ulong[]{0x200UL});
		public static readonly BitSet _ENUM_END_in_enum_end_meta416 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _ENUM_in_enum_definition427 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _ID_in_enum_definition430 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _enum_entry_list_in_enum_definition432 = new BitSet(new ulong[]{0x4000000UL});
		public static readonly BitSet _SEMICOLON_in_enum_definition434 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _NAMESPACE_in_namespace_wrapper446 = new BitSet(new ulong[]{0x4000UL});
		public static readonly BitSet _qualified_id_in_namespace_wrapper449 = new BitSet(new ulong[]{0x10000UL});
		public static readonly BitSet _LBRACE_in_namespace_wrapper451 = new BitSet(new ulong[]{0x80UL});
		public static readonly BitSet _enum_definition_in_namespace_wrapper454 = new BitSet(new ulong[]{0x1000000UL});
		public static readonly BitSet _RBRACE_in_namespace_wrapper456 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _namespace_wrapper_in_enum_entry_point468 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enum_definition_in_enum_entry_point472 = new BitSet(new ulong[]{0x2UL});
		public static readonly BitSet _enum_begin_meta_in_parse487 = new BitSet(new ulong[]{0x100080UL});
		public static readonly BitSet _enum_entry_point_in_parse489 = new BitSet(new ulong[]{0x80000UL});
		public static readonly BitSet _enum_end_meta_in_parse491 = new BitSet(new ulong[]{0x2UL});
	}
	#endregion Follow sets
}
